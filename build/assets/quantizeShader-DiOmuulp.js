import{C as Tn,e as ue,V as me,f as Ze,g as Jr,d as kt,h as _o,i as bo,L as xn,j as Qr,U as ea,I as ta,k as sa,l as na,m as oa,D as Ot,n as ia,o as Do,p as ra,F as aa,q as zo,r as vn,N as $n,s as ca,t as Dt,u as Fo,v as Po,w as ua,x as la,y as Wn,z as da,A as ha,G as Ye,H as qn,O as pa,J as ma,K as ga,Q as fa,X as Na,Y as ya,Z as Ta,_ as xa,$ as va,c as Sa,a0 as Ma,a1 as Xn,a2 as Aa,a3 as Ra,a4 as Ca,a5 as Xt,a6 as Uo,a7 as wa,a8 as Ea,a9 as Bo,aa as Ia,ab as ko,ac as La,M as Va,ad as Oa,ae as _a,af as ba,ag as Da,ah as za,ai as Fa,aj as Pa,ak as Ua}from"./RenderPass-DKVN8-Vw.js";const jn={VERTEX:"vertex",FRAGMENT:"fragment"},z={NONE:"none",FRAME:"frame",RENDER:"render",OBJECT:"object"},fs=["x","y","z","w"];function Go(n,e=!1){let t="{";n.isNode===!0&&(t+=n.id);for(const{property:s,childNode:o}of is(n))t+=","+s.slice(0,-4)+":"+o.getCacheKey(e);return t+="}",t}function*is(n,e=!1){for(const t in n){if(t.startsWith("_")===!0)continue;const s=n[t];if(Array.isArray(s)===!0)for(let o=0;o<s.length;o++){const i=s[o];i&&(i.isNode===!0||e&&typeof i.toJSON=="function")&&(yield{property:t,index:o,childNode:i})}else if(s&&s.isNode===!0)yield{property:t,childNode:s};else if(typeof s=="object")for(const o in s){const i=s[o];i&&(i.isNode===!0||e&&typeof i.toJSON=="function")&&(yield{property:t,index:o,childNode:i})}}}function je(n){if(n==null)return null;const e=typeof n;return n.isNode===!0?"node":e==="number"?"float":e==="boolean"?"bool":e==="string"?"string":e==="function"?"shader":n.isVector2===!0?"vec2":n.isVector3===!0?"vec3":n.isVector4===!0?"vec4":n.isMatrix3===!0?"mat3":n.isMatrix4===!0?"mat4":n.isColor===!0?"color":n instanceof ArrayBuffer?"ArrayBuffer":null}function Ho(n,...e){const t=n?n.slice(-4):void 0;return e.length===1&&(t==="vec2"?e=[e[0],e[0]]:t==="vec3"?e=[e[0],e[0],e[0]]:t==="vec4"&&(e=[e[0],e[0],e[0],e[0]])),n==="color"?new Tn(...e):t==="vec2"?new ue(...e):t==="vec3"?new me(...e):t==="vec4"?new Ze(...e):t==="mat3"?new Jr(...e):t==="mat4"?new kt(...e):n==="bool"?e[0]||!1:n==="float"||n==="int"||n==="uint"?e[0]||0:n==="string"?e[0]||"":n==="ArrayBuffer"?Wo(e[0]):null}function $o(n){let e="";const t=new Uint8Array(n);for(let s=0;s<t.length;s++)e+=String.fromCharCode(t[s]);return btoa(e)}function Wo(n){return Uint8Array.from(atob(n),e=>e.charCodeAt(0)).buffer}const Zn=new Map;let Ba=0;class V extends _o{constructor(e=null){super(),this.nodeType=e,this.updateType=z.NONE,this.updateBeforeType=z.NONE,this.updateAfterType=z.NONE,this.uuid=bo.generateUUID(),this.version=0,this._cacheKey=null,this._cacheKeyVersion=0,this.global=!1,this.isNode=!0,Object.defineProperty(this,"id",{value:Ba++})}set needsUpdate(e){e===!0&&this.version++}get type(){return this.constructor.type}onUpdate(e,t){return this.updateType=t,this.update=e.bind(this.getSelf()),this}onFrameUpdate(e){return this.onUpdate(e,z.FRAME)}onRenderUpdate(e){return this.onUpdate(e,z.RENDER)}onObjectUpdate(e){return this.onUpdate(e,z.OBJECT)}onReference(e){return this.updateReference=e.bind(this.getSelf()),this}getSelf(){return this.self||this}updateReference(){return this}isGlobal(){return this.global}*getChildren(){for(const{childNode:e}of is(this))yield e}dispose(){this.dispatchEvent({type:"dispose"})}traverse(e){e(this);for(const t of this.getChildren())t.traverse(e)}getCacheKey(e=!1){return e=e||this.version!==this._cacheKeyVersion,(e===!0||this._cacheKey===null)&&(this._cacheKey=Go(this,e),this._cacheKeyVersion=this.version),this._cacheKey}getHash(){return this.uuid}getUpdateType(){return this.updateType}getUpdateBeforeType(){return this.updateBeforeType}getUpdateAfterType(){return this.updateAfterType}getElementType(e){const t=this.getNodeType(e);return e.getElementType(t)}getNodeType(e){const t=e.getNodeProperties(this);return t.outputNode?t.outputNode.getNodeType(e):this.nodeType}getShared(e){const t=this.getHash(e);return e.getNodeFromHash(t)||this}setup(e){const t=e.getNodeProperties(this);let s=0;for(const o of this.getChildren())t["node"+s++]=o;return null}construct(e){return console.warn("THREE.Node: construct() is deprecated. Use setup() instead."),this.setup(e)}increaseUsage(e){const t=e.getDataFromNode(this);return t.usageCount=t.usageCount===void 0?1:t.usageCount+1,t.usageCount}analyze(e){if(this.increaseUsage(e)===1){const s=e.getNodeProperties(this);for(const o of Object.values(s))o&&o.isNode===!0&&o.build(e)}}generate(e,t){const{outputNode:s}=e.getNodeProperties(this);if(s&&s.isNode===!0)return s.build(e,t)}updateBefore(){console.warn("Abstract function.")}updateAfter(){console.warn("Abstract function.")}update(){console.warn("Abstract function.")}build(e,t=null){const s=this.getShared(e);if(this!==s)return s.build(e,t);e.addNode(this),e.addChain(this);let o=null;const i=e.getBuildStage();if(i==="setup"){this.updateReference(e);const r=e.getNodeProperties(this);if(r.initialized!==!0){const a=e.stack.nodes.length;r.initialized=!0,r.outputNode=this.setup(e),r.outputNode!==null&&e.stack.nodes.length!==a&&(r.outputNode=e.stack);for(const c of Object.values(r))c&&c.isNode===!0&&c.build(e)}}else if(i==="analyze")this.analyze(e);else if(i==="generate")if(this.generate.length===1){const a=this.getNodeType(e),c=e.getDataFromNode(this);o=c.snippet,o===void 0&&(o=this.generate(e)||"",c.snippet=o),o=e.format(o,a,t)}else o=this.generate(e,t)||"";return e.removeChain(this),o}getSerializeChildren(){return is(this)}serialize(e){const t=this.getSerializeChildren(),s={};for(const{property:o,index:i,childNode:r}of t)i!==void 0?(s[o]===void 0&&(s[o]=Number.isInteger(i)?[]:{}),s[o][i]=r.toJSON(e.meta).uuid):s[o]=r.toJSON(e.meta).uuid;Object.keys(s).length>0&&(e.inputNodes=s)}deserialize(e){if(e.inputNodes!==void 0){const t=e.meta.nodes;for(const s in e.inputNodes)if(Array.isArray(e.inputNodes[s])){const o=[];for(const i of e.inputNodes[s])o.push(t[i]);this[s]=o}else if(typeof e.inputNodes[s]=="object"){const o={};for(const i in e.inputNodes[s]){const r=e.inputNodes[s][i];o[i]=t[r]}this[s]=o}else{const o=e.inputNodes[s];this[s]=t[o]}}}toJSON(e){const{uuid:t,type:s}=this,o=e===void 0||typeof e=="string";o&&(e={textures:{},images:{},nodes:{}});let i=e.nodes[t];i===void 0&&(i={uuid:t,type:s,meta:e,metadata:{version:4.6,type:"Node",generator:"Node.toJSON"}},o!==!0&&(e.nodes[i.uuid]=i),this.serialize(i),delete i.meta);function r(a){const c=[];for(const u in a){const l=a[u];delete l.metadata,c.push(l)}return c}if(o){const a=r(e.textures),c=r(e.images),u=r(e.nodes);a.length>0&&(i.textures=a),c.length>0&&(i.images=c),u.length>0&&(i.nodes=u)}return i}}function T(n,e){if(typeof e!="function"||!n)throw new Error(`Node class ${n} is not a class`);if(Zn.has(n)){console.warn(`Redefinition of node class ${n}`);return}Zn.set(n,e),e.type=n}class P extends V{constructor(e){super(e),this.isTempNode=!0}hasDependencies(e){return e.getDataFromNode(this).usageCount>1}build(e,t){if(e.getBuildStage()==="generate"){const o=e.getVectorType(this.getNodeType(e,t)),i=e.getDataFromNode(this);if(i.propertyName!==void 0)return e.format(i.propertyName,o,t);if(o!=="void"&&t!=="void"&&this.hasDependencies(e)){const r=super.build(e,o),a=e.getVarFromNode(this,null,o),c=e.getPropertyName(a);return e.addLineFlowCode(`${c} = ${r}`),i.snippet=r,i.propertyName=c,e.format(i.propertyName,o,t)}}return super.build(e,t)}}T("TempNode",P);class At extends V{constructor(e,t){super(),this.node=e,this.indexNode=t,this.isArrayElementNode=!0}getNodeType(e){return this.node.getElementType(e)}generate(e){const t=this.node.build(e),s=this.indexNode.build(e,"uint");return`${t}[ ${s} ]`}}T("ArrayElementNode",At);class Sn extends V{constructor(e,t){super(),this.node=e,this.convertTo=t}getNodeType(e){const t=this.node.getNodeType(e);let s=null;for(const o of this.convertTo.split("|"))(s===null||e.getTypeLength(t)===e.getTypeLength(o))&&(s=o);return s}serialize(e){super.serialize(e),e.convertTo=this.convertTo}deserialize(e){super.deserialize(e),this.convertTo=e.convertTo}generate(e,t){const s=this.node,o=this.getNodeType(e),i=s.build(e,o);return e.format(i,o,t)}}T("ConvertNode",Sn);class qo extends P{constructor(e=[],t=null){super(t),this.nodes=e}getNodeType(e){return this.nodeType!==null?e.getVectorType(this.nodeType):e.getTypeFromLength(this.nodes.reduce((t,s)=>t+e.getTypeLength(s.getNodeType(e)),0))}generate(e,t){const s=this.getNodeType(e),o=this.nodes,i=e.getComponentType(s),r=[];for(const c of o){let u=c.build(e);const l=e.getComponentType(c.getNodeType(e));l!==i&&(u=e.format(u,l,i)),r.push(u)}const a=`${e.getType(s)}( ${r.join(", ")} )`;return e.format(a,s,t)}}T("JoinNode",qo);const ka=fs.join("");class Js extends V{constructor(e,t="x"){super(),this.node=e,this.components=t,this.isSplitNode=!0}getVectorLength(){let e=this.components.length;for(const t of this.components)e=Math.max(fs.indexOf(t)+1,e);return e}getComponentType(e){return e.getComponentType(this.node.getNodeType(e))}getNodeType(e){return e.getTypeFromLength(this.components.length,this.getComponentType(e))}generate(e,t){const s=this.node,o=e.getTypeLength(s.getNodeType(e));let i=null;if(o>1){let r=null;this.getVectorLength()>=o&&(r=e.getTypeFromLength(this.getVectorLength(),this.getComponentType(e)));const c=s.build(e,r);this.components.length===o&&this.components===ka.slice(0,this.components.length)?i=e.format(c,r,t):i=e.format(`${c}.${this.components}`,this.getNodeType(e),t)}else i=s.build(e,t);return i}serialize(e){super.serialize(e),e.components=this.components}deserialize(e){super.deserialize(e),this.components=e.components}}T("SplitNode",Js);class Xo extends P{constructor(e,t,s){super(),this.sourceNode=e,this.components=t,this.targetNode=s}getNodeType(e){return this.sourceNode.getNodeType(e)}generate(e){const{sourceNode:t,components:s,targetNode:o}=this,i=this.getNodeType(e),r=e.getTypeFromLength(s.length),a=o.build(e,r),c=t.build(e,i),u=e.getTypeLength(i),l=[];for(let h=0;h<u;h++){const d=fs[h];d===s[0]?(l.push(a),h+=s.length-1):l.push(c+"."+d)}return`${e.getType(i)}( ${l.join(", ")} )`}}T("SetNode",Xo);class Ns extends V{constructor(e,t=null){super(t),this.isInputNode=!0,this.value=e,this.precision=null}getNodeType(){return this.nodeType===null?je(this.value):this.nodeType}getInputType(e){return this.getNodeType(e)}setPrecision(e){return this.precision=e,this}serialize(e){super.serialize(e),e.value=this.value,this.value&&this.value.toArray&&(e.value=this.value.toArray()),e.valueType=je(this.value),e.nodeType=this.nodeType,e.valueType==="ArrayBuffer"&&(e.value=$o(e.value)),e.precision=this.precision}deserialize(e){super.deserialize(e),this.nodeType=e.nodeType,this.value=Array.isArray(e.value)?Ho(e.valueType,...e.value):e.value,this.precision=e.precision||null,this.value&&this.value.fromArray&&(this.value=this.value.fromArray(e.value))}generate(){console.warn("Abstract function.")}}T("InputNode",Ns);class Ue extends Ns{constructor(e,t=null){super(e,t),this.isConstNode=!0}generateConst(e){return e.generateConst(this.getNodeType(e),this.value)}generate(e,t){const s=this.getNodeType(e);return e.format(this.generateConst(e),s,t)}}T("ConstNode",Ue);let St=null;const ht=new Map;function m(n,e){if(ht.has(n)){console.warn(`Redefinition of node element ${n}`);return}if(typeof e!="function")throw new Error(`Node element ${n} is not a function`);ht.set(n,e)}const Yn=n=>n.replace(/r|s/g,"x").replace(/g|t/g,"y").replace(/b|p/g,"z").replace(/a|q/g,"w"),jo={setup(n,e){const t=e.shift();return n(xs(t),...e)},get(n,e,t){if(typeof e=="string"&&n[e]===void 0){if(n.isStackNode!==!0&&e==="assign")return(...s)=>(St.assign(t,...s),t);if(ht.has(e)){const s=ht.get(e);return n.isStackNode?(...o)=>t.add(s(...o)):(...o)=>s(t,...o)}else{if(e==="self")return n;if(e.endsWith("Assign")&&ht.has(e.slice(0,e.length-6))){const s=ht.get(e.slice(0,e.length-6));return n.isStackNode?(...o)=>t.assign(o[0],s(...o)):(...o)=>t.assign(s(t,...o))}else{if(/^[xyzwrgbastpq]{1,4}$/.test(e)===!0)return e=Yn(e),M(new Js(t,e));if(/^set[XYZWRGBASTPQ]{1,4}$/.test(e)===!0)return e=Yn(e.slice(3).toLowerCase()),e=e.split("").sort().join(""),s=>M(new Xo(n,e,s));if(e==="width"||e==="height"||e==="depth")return e==="width"?e="x":e==="height"?e="y":e==="depth"&&(e="z"),M(new Js(n,e));if(/^\d+$/.test(e)===!0)return M(new At(t,new Ue(Number(e),"uint")))}}}return Reflect.get(n,e,t)},set(n,e,t,s){return typeof e=="string"&&n[e]===void 0&&(/^[xyzwrgbastpq]{1,4}$/.test(e)===!0||e==="width"||e==="height"||e==="depth"||/^\d+$/.test(e)===!0)?(s[e].assign(t),!0):Reflect.set(n,e,t,s)}},Os=new WeakMap,Kn=new WeakMap,Ga=function(n,e=null){const t=je(n);if(t==="node"){let s=Os.get(n);return s===void 0&&(s=new Proxy(n,jo),Os.set(n,s),Os.set(s,s)),s}else{if(e===null&&(t==="float"||t==="boolean")||t&&t!=="shader"&&t!=="string")return M(Qs(n,e));if(t==="shader")return A(n)}return n},Ha=function(n,e=null){for(const t in n)n[t]=M(n[t],e);return n},$a=function(n,e=null){const t=n.length;for(let s=0;s<t;s++)n[s]=M(n[s],e);return n},Wa=function(n,e=null,t=null,s=null){const o=i=>M(s!==null?Object.assign(i,s):i);return e===null?(...i)=>o(new n(...ft(i))):t!==null?(t=M(t),(...i)=>o(new n(e,...ft(i),t))):(...i)=>o(new n(e,...ft(i)))},qa=function(n,...e){return M(new n(...ft(e)))};class Xa extends V{constructor(e,t){super(),this.shaderNode=e,this.inputNodes=t}getNodeType(e){const t=e.getNodeProperties(this);return t.outputNode===null&&(t.outputNode=this.setupOutput(e)),t.outputNode.getNodeType(e)}call(e){const{shaderNode:t,inputNodes:s}=this;if(t.layout){let r=Kn.get(e.constructor);r===void 0&&(r=new WeakMap,Kn.set(e.constructor,r));let a=r.get(t);return a===void 0&&(a=M(e.buildFunctionNode(t)),r.set(t,a)),e.currentFunctionNode!==null&&e.currentFunctionNode.includes.push(a),M(a.call(s))}const o=t.jsFunc,i=s!==null?o(s,e.stack,e):o(e.stack,e);return M(i)}setup(e){const{outputNode:t}=e.getNodeProperties(this);return t||this.setupOutput(e)}setupOutput(e){return e.addStack(),e.stack.outputNode=this.call(e),e.removeStack()}generate(e,t){const{outputNode:s}=e.getNodeProperties(this);return s===null?this.call(e).build(e,t):super.generate(e,t)}}class ja extends V{constructor(e){super(),this.jsFunc=e,this.layout=null,this.global=!0}get isArrayInput(){return/^\((\s+)?\[/.test(this.jsFunc.toString())}setLayout(e){return this.layout=e,this}call(e=null){return xs(e),M(new Xa(this,e))}setup(){return this.call()}}const Za=[!1,!0],Ya=[0,1,2,3],Ka=[-1,-2],Zo=[.5,1.5,1/3,1e-6,1e6,Math.PI,Math.PI*2,1/Math.PI,2/Math.PI,1/(Math.PI*2),Math.PI/2],Mn=new Map;for(const n of Za)Mn.set(n,new Ue(n));const An=new Map;for(const n of Ya)An.set(n,new Ue(n,"uint"));const Rn=new Map([...An].map(n=>new Ue(n.value,"int")));for(const n of Ka)Rn.set(n,new Ue(n,"int"));const ys=new Map([...Rn].map(n=>new Ue(n.value)));for(const n of Zo)ys.set(n,new Ue(n));for(const n of Zo)ys.set(-n,new Ue(-n));const Ts={bool:Mn,uint:An,ints:Rn,float:ys},Jn=new Map([...Mn,...ys]),Qs=(n,e)=>Jn.has(n)?Jn.get(n):n.isNode===!0?n:new Ue(n,e),Ja=n=>{try{return n.getNodeType()}catch{return}},k=function(n,e=null){return(...t)=>{if((t.length===0||!["bool","float","int","uint"].includes(n)&&t.every(o=>typeof o!="object"))&&(t=[Ho(n,...t)]),t.length===1&&e!==null&&e.has(t[0]))return M(e.get(t[0]));if(t.length===1){const o=Qs(t[0],n);return Ja(o)===n?M(o):M(new Sn(o,n))}const s=t.map(o=>Qs(o));return M(new qo(s,n))}},Qn=n=>n&&n.value,Qa=n=>n!=null?n.nodeType||n.convertTo||(typeof n=="string"?n:null):null;function _t(n){return new Proxy(new ja(n),jo)}const M=(n,e=null)=>Ga(n,e),xs=(n,e=null)=>new Ha(n,e),ft=(n,e=null)=>new $a(n,e),g=(...n)=>new Wa(...n),R=(...n)=>new qa(...n),A=n=>{const e=new _t(n),t=(...s)=>{let o;return xs(s),s[0]&&s[0].isNode?o=[...s]:o=s[0],e.call(o)};return t.shaderNode=e,t.setLayout=s=>(e.setLayout(s),t),t};T("ShaderNode",_t);m("toGlobal",n=>(n.global=!0,n));const eo=n=>{St=n},ec=()=>St,K=(...n)=>St.if(...n);function tc(n){return St&&St.add(n),n}m("append",tc);const sc=new k("color"),y=new k("float",Ts.float),ee=new k("int",Ts.ints),nc=new k("uint",Ts.uint),oc=new k("bool",Ts.bool),S=new k("vec2"),Xe=new k("ivec2"),ic=new k("uvec2"),rc=new k("bvec2"),f=new k("vec3"),ac=new k("ivec3"),cc=new k("uvec3"),uc=new k("bvec3"),w=new k("vec4"),lc=new k("ivec4"),dc=new k("uvec4"),hc=new k("bvec4"),Cn=new k("mat2"),pc=new k("imat2"),mc=new k("umat2"),gc=new k("bmat2"),le=new k("mat3"),fc=new k("imat3"),Nc=new k("umat3"),yc=new k("bmat3"),Nt=new k("mat4"),Tc=new k("imat4"),xc=new k("umat4"),vc=new k("bmat4");m("toColor",sc);m("toFloat",y);m("toInt",ee);m("toUint",nc);m("toBool",oc);m("toVec2",S);m("toIvec2",Xe);m("toUvec2",ic);m("toBvec2",rc);m("toVec3",f);m("toIvec3",ac);m("toUvec3",cc);m("toBvec3",uc);m("toVec4",w);m("toIvec4",lc);m("toUvec4",dc);m("toBvec4",hc);m("toMat2",Cn);m("toImat2",pc);m("toUmat2",mc);m("toBmat2",gc);m("toMat3",le);m("toImat3",fc);m("toUmat3",Nc);m("toBmat3",yc);m("toMat4",Nt);m("toImat4",Tc);m("toUmat4",xc);m("toBmat4",vc);const Sc=g(At),Mc=(n,e)=>M(new Sn(M(n),e));m("element",Sc);m("convert",Mc);class Yo extends P{constructor(e,t){super(),this.targetNode=e,this.sourceNode=t}hasDependencies(){return!1}getNodeType(e,t){return t!=="void"?this.targetNode.getNodeType(e):"void"}needsSplitAssign(e){const{targetNode:t}=this;if(e.isAvailable("swizzleAssign")===!1&&t.isSplitNode&&t.components.length>1){const s=e.getTypeLength(t.node.getNodeType(e));return fs.join("").slice(0,s)!==t.components}return!1}generate(e,t){const{targetNode:s,sourceNode:o}=this,i=this.needsSplitAssign(e),r=s.getNodeType(e),a=s.context({assign:!0}).build(e),c=o.build(e,r),u=o.getNodeType(e),l=e.getDataFromNode(this);let h;if(l.initialized===!0)t!=="void"&&(h=a);else if(i){const d=e.getVarFromNode(this,null,r),x=e.getPropertyName(d);e.addLineFlowCode(`${x} = ${c}`);const v=s.node.context({assign:!0}).build(e);for(let C=0;C<s.components.length;C++){const E=s.components[C];e.addLineFlowCode(`${v}.${E} = ${x}[ ${C} ]`)}t!=="void"&&(h=a)}else h=`${a} = ${c}`,(t==="void"||u==="void")&&(e.addLineFlowCode(h),t!=="void"&&(h=a));return l.initialized=!0,e.format(h,r,t)}}const Ac=g(Yo);T("AssignNode",Yo);m("assign",Ac);class Ko extends V{constructor(e,t=null){super(),this.node=e,this.name=t,this.isVaryingNode=!0}isGlobal(){return!0}getHash(e){return this.name||super.getHash(e)}getNodeType(e){return this.node.getNodeType(e)}setupVarying(e){const t=e.getNodeProperties(this);let s=t.varying;if(s===void 0){const o=this.name,i=this.getNodeType(e);t.varying=s=e.getVaryingFromNode(this,o,i),t.node=this.node}return s.needsInterpolation||(s.needsInterpolation=e.shaderStage==="fragment"),s}setup(e){this.setupVarying(e)}analyze(e){return this.setupVarying(e),this.node.analyze(e)}generate(e){const t=e.getNodeProperties(this),s=this.setupVarying(e);if(t.propertyName===void 0){const o=this.getNodeType(e),i=e.getPropertyName(s,jn.VERTEX);e.flowNodeFromShaderStage(jn.VERTEX,this.node,o,i),t.propertyName=i}return e.getPropertyName(s)}}const J=g(Ko);m("varying",J);T("VaryingNode",Ko);class wn extends V{constructor(e,t=null,s=null){super(t),this.defaultNode=s,this.global=!0,this._attributeName=e}getHash(e){return this.getAttributeName(e)}getNodeType(e){let t=super.getNodeType(e);if(t===null){const s=this.getAttributeName(e);if(e.hasGeometryAttribute(s)){const o=e.geometry.getAttribute(s);t=e.getTypeFromAttribute(o)}else t="float"}return t}setAttributeName(e){return this._attributeName=e,this}getAttributeName(){return this._attributeName}generate(e){const t=this.getAttributeName(e),s=this.getNodeType(e);if(e.hasGeometryAttribute(t)===!0){const i=e.geometry.getAttribute(t),r=e.getTypeFromAttribute(i),a=e.getAttribute(t,r);return e.shaderStage==="vertex"?e.format(a.name,r,s):J(this).build(e,s)}else{console.warn(`AttributeNode: Vertex attribute "${t}" not found on geometry.`);const{defaultNode:i}=this;return i!==null?i.build(e,s):e.generateConst(s)}}}const ae=(n,e,t)=>M(new wn(n,e,M(t)));T("AttributeNode",wn);class Jo extends V{constructor(e,t){super(),this.isBypassNode=!0,this.outputNode=e,this.callNode=t}getNodeType(e){return this.outputNode.getNodeType(e)}generate(e){const t=this.callNode.build(e,"void");return t!==""&&e.addLineFlowCode(t),this.outputNode.build(e)}}const Qo=g(Jo);m("bypass",Qo);T("BypassNode",Jo);class ei extends V{constructor(e,t=!0){super(),this.node=e,this.parent=t,this.isCacheNode=!0}getNodeType(e){return this.node.getNodeType(e)}build(e,...t){const s=e.getCache(),o=e.getCacheFromNode(this,parent);e.setCache(o);const i=this.node.build(e,...t);return e.setCache(s),i}}const es=(n,...e)=>M(new ei(M(n),...e));m("cache",es);T("CacheNode",ei);class En extends V{constructor(e,t={}){super(),this.isContextNode=!0,this.node=e,this.context=t}getNodeType(e){return this.node.getNodeType(e)}analyze(e){this.node.build(e)}setup(e){const t=e.getContext();e.setContext({...e.context,...this.context});const s=this.node.build(e);return e.setContext(t),s}generate(e,t){const s=e.getContext();e.setContext({...e.context,...this.context});const o=this.node.build(e,t);return e.setContext(s),o}}const bt=g(En),Rc=(n,e)=>bt(n,{label:e});m("context",bt);m("label",Rc);T("ContextNode",En);class fe extends V{constructor(e){super("uint"),this.scope=e,this.isInstanceIndexNode=!0}generate(e){const t=this.getNodeType(e),s=this.scope;let o;if(s===fe.VERTEX)o=e.getVertexIndex();else if(s===fe.INSTANCE)o=e.getInstanceIndex();else if(s===fe.DRAW)o=e.getDrawIndex();else throw new Error("THREE.IndexNode: Unknown scope: "+s);let i;return e.shaderStage==="vertex"||e.shaderStage==="compute"?i=o:i=J(this).build(e,t),i}}fe.VERTEX="vertex";fe.INSTANCE="instance";fe.DRAW="draw";const Cc=R(fe,fe.VERTEX),In=R(fe,fe.INSTANCE),wc=R(fe,fe.DRAW);T("IndexNode",fe);class vs{start(){}finish(){}direct(){}directRectArea(){}indirectDiffuse(){}indirectSpecular(){}ambientOcclusion(){}}class ti extends V{constructor(e,t=null){super(),this.node=e,this.name=t,this.global=!0,this.isVarNode=!0}getHash(e){return this.name||super.getHash(e)}getNodeType(e){return this.node.getNodeType(e)}generate(e){const{node:t,name:s}=this,o=e.getVarFromNode(this,s,e.getVectorType(this.getNodeType(e))),i=e.getPropertyName(o),r=t.build(e,o.type);return e.addLineFlowCode(`${i} = ${r}`),i}}const rs=g(ti);m("temp",rs);m("toVar",(...n)=>rs(...n).append());T("VarNode",ti);class U extends V{constructor(e,t=null,s=!1){super(e),this.name=t,this.varying=s,this.isPropertyNode=!0}getHash(e){return this.name||super.getHash(e)}isGlobal(){return!0}generate(e){let t;return this.varying===!0?(t=e.getVaryingFromNode(this,this.name),t.needsInterpolation=!0):t=e.getVarFromNode(this,this.name),e.getPropertyName(t)}}const j=(n,e)=>M(new U(n,e)),Ve=(n,e)=>M(new U(n,e,!0)),H=R(U,"vec4","DiffuseColor"),Ge=R(U,"float","Roughness"),as=R(U,"float","Metalness"),en=R(U,"float","Clearcoat"),cs=R(U,"float","ClearcoatRoughness"),pt=R(U,"vec3","Sheen"),Ln=R(U,"float","SheenRoughness"),Vn=R(U,"float","Iridescence"),si=R(U,"float","IridescenceIOR"),ni=R(U,"float","IridescenceThickness"),tn=R(U,"float","AlphaT"),st=R(U,"float","Anisotropy"),ts=R(U,"vec3","AnisotropyT"),yt=R(U,"vec3","AnisotropyB"),Se=R(U,"color","SpecularColor"),us=R(U,"float","SpecularF90"),sn=R(U,"float","Shininess"),Ec=R(U,"vec4","Output"),Tt=R(U,"float","dashSize"),ls=R(U,"float","gapSize");R(U,"float","pointWidth");const ss=R(U,"float","IOR"),nn=R(U,"float","Transmission"),oi=R(U,"float","Thickness"),ii=R(U,"float","AttenuationDistance"),ri=R(U,"color","AttenuationColor"),ai=R(U,"float","Dispersion");T("PropertyNode",U);class Ic extends U{constructor(e,t=null){super(e,t),this.isParameterNode=!0}getHash(){return this.uuid}generate(){return this.name}}T("ParameterNode",Ic);class On extends V{constructor(e="",t=[],s=""){super("code"),this.isCodeNode=!0,this.code=e,this.language=s,this.includes=t}isGlobal(){return!0}setIncludes(e){return this.includes=e,this}getIncludes(){return this.includes}generate(e){const t=this.getIncludes(e);for(const o of t)o.build(e);const s=e.getCodeFromNode(this,this.getNodeType(e));return s.code=this.code,s.code}serialize(e){super.serialize(e),e.code=this.code,e.language=this.language}deserialize(e){super.deserialize(e),this.code=e.code,this.language=e.language}}g(On);T("CodeNode",On);class Lc extends On{constructor(e="",t=[],s=""){super(e,t,s),this.keywords={}}getNodeType(e){return this.getNodeFunction(e).type}getInputs(e){return this.getNodeFunction(e).inputs}getNodeFunction(e){const t=e.getDataFromNode(this);let s=t.nodeFunction;return s===void 0&&(s=e.parser.parseFunction(this.code),t.nodeFunction=s),s}generate(e,t){super.generate(e);const s=this.getNodeFunction(e),o=s.name,i=s.type,r=e.getCodeFromNode(this,i);o!==""&&(r.name=o);const a=e.getPropertyName(r);let c=this.getNodeFunction(e).getCode(a);const u=this.keywords,l=Object.keys(u);if(l.length>0)for(const h of l){const d=new RegExp(`\\b${h}\\b`,"g"),x=u[h].build(e,"property");c=c.replace(d,x)}return r.code=c+`
`,t==="property"?a:e.format(`${a}()`,i,t)}}T("FunctionNode",Lc);class _n extends V{constructor(e,t=!1){super("string"),this.name=e,this.version=0,this.shared=t,this.isUniformGroup=!0}set needsUpdate(e){e===!0&&this.version++}}const Vc=n=>new _n(n),bn=n=>new _n(n,!0);bn("frame");bn("render");const Oc=Vc("object");T("UniformGroupNode",_n);class rt extends Ns{constructor(e,t=null){super(e,t),this.isUniformNode=!0,this.name="",this.groupNode=Oc}label(e){return this.name=e,this}setGroup(e){return this.groupNode=e,this}getGroup(){return this.groupNode}getUniformHash(e){return this.getHash(e)}onUpdate(e,t){const s=this.getSelf();return e=e.bind(s),super.onUpdate(o=>{const i=e(o,s);i!==void 0&&(this.value=i)},t)}generate(e,t){const s=this.getNodeType(e),o=this.getUniformHash(e);let i=e.getNodeFromHash(o);i===void 0&&(e.setHashNode(this,o),i=this);const r=i.getInputType(e),a=e.getUniformFromNode(i,r,e.shaderStage,this.name||e.context.label),c=e.getPropertyName(a);return e.context.label!==void 0&&delete e.context.label,e.format(c,s,t)}}const O=(n,e)=>{const t=Qa(e||n),s=n&&n.isNode===!0?n.node&&n.node.value||n.value:n;return M(new rt(s,t))};T("UniformNode",rt);const xe=n=>ae("uv"+(n>0?n:""),"vec2");class ci extends V{constructor(e,t=null){super("uvec2"),this.isTextureSizeNode=!0,this.textureNode=e,this.levelNode=t}generate(e,t){const s=this.textureNode.build(e,"property"),o=this.levelNode.build(e,"int");return e.format(`${e.getMethod("textureDimensions")}( ${s}, ${o} )`,this.getNodeType(e),t)}}const ds=g(ci);m("textureSize",ds);T("TextureSizeNode",ci);class q extends P{constructor(e,t,s,...o){if(super(),o.length>0){let i=new q(e,t,s);for(let r=0;r<o.length-1;r++)i=new q(e,i,o[r]);t=i,s=o[o.length-1]}this.op=e,this.aNode=t,this.bNode=s}getNodeType(e,t){const s=this.op,o=this.aNode,i=this.bNode,r=o.getNodeType(e),a=typeof i<"u"?i.getNodeType(e):null;if(r==="void"||a==="void")return"void";if(s==="%")return r;if(s==="~"||s==="&"||s==="|"||s==="^"||s===">>"||s==="<<")return e.getIntegerType(r);if(s==="!"||s==="=="||s==="&&"||s==="||"||s==="^^")return"bool";if(s==="<"||s===">"||s==="<="||s===">="){const c=t?e.getTypeLength(t):Math.max(e.getTypeLength(r),e.getTypeLength(a));return c>1?`bvec${c}`:"bool"}else return r==="float"&&e.isMatrix(a)?a:e.isMatrix(r)&&e.isVector(a)?e.getVectorFromMatrix(r):e.isVector(r)&&e.isMatrix(a)?e.getVectorFromMatrix(a):e.getTypeLength(a)>e.getTypeLength(r)?a:r}generate(e,t){const s=this.op,o=this.aNode,i=this.bNode,r=this.getNodeType(e,t);let a=null,c=null;r!=="void"?(a=o.getNodeType(e),c=typeof i<"u"?i.getNodeType(e):null,s==="<"||s===">"||s==="<="||s===">="||s==="=="?e.isVector(a)?c=a:a=c="float":s===">>"||s==="<<"?(a=r,c=e.changeComponentType(c,"uint")):e.isMatrix(a)&&e.isVector(c)?c=e.getVectorFromMatrix(a):e.isVector(a)&&e.isMatrix(c)?a=e.getVectorFromMatrix(c):a=c=r):a=c=r;const u=o.build(e,a),l=typeof i<"u"?i.build(e,c):null,h=e.getTypeLength(t),d=e.getFunctionOperator(s);if(t!=="void")return s==="<"&&h>1?e.format(`${e.getMethod("lessThan")}( ${u}, ${l} )`,r,t):s==="<="&&h>1?e.format(`${e.getMethod("lessThanEqual")}( ${u}, ${l} )`,r,t):s===">"&&h>1?e.format(`${e.getMethod("greaterThan")}( ${u}, ${l} )`,r,t):s===">="&&h>1?e.format(`${e.getMethod("greaterThanEqual")}( ${u}, ${l} )`,r,t):s==="!"||s==="~"?e.format(`(${s}${u})`,a,t):d?e.format(`${d}( ${u}, ${l} )`,r,t):e.format(`( ${u} ${s} ${l} )`,r,t);if(a!=="void")return d?e.format(`${d}( ${u}, ${l} )`,r,t):e.format(`${u} ${s} ${l}`,r,t)}serialize(e){super.serialize(e),e.op=this.op}deserialize(e){super.deserialize(e),this.op=e.op}}const ye=g(q,"+"),ze=g(q,"-"),B=g(q,"*"),qe=g(q,"/"),_c=g(q,"%"),bc=g(q,"=="),Dc=g(q,"!="),zc=g(q,"<"),Fc=g(q,">"),Pc=g(q,"<="),Uc=g(q,">="),Bc=g(q,"&&"),kc=g(q,"||"),Gc=g(q,"!"),Hc=g(q,"^^"),$c=g(q,"&"),Wc=g(q,"~"),qc=g(q,"|"),Xc=g(q,"^"),jc=g(q,"<<"),Zc=g(q,">>");m("add",ye);m("sub",ze);m("mul",B);m("div",qe);m("remainder",_c);m("equal",bc);m("notEqual",Dc);m("lessThan",zc);m("greaterThan",Fc);m("lessThanEqual",Pc);m("greaterThanEqual",Uc);m("and",Bc);m("or",kc);m("not",Gc);m("xor",Hc);m("bitAnd",$c);m("bitNot",Wc);m("bitOr",qc);m("bitXor",Xc);m("shiftLeft",jc);m("shiftRight",Zc);T("OperatorNode",q);class p extends P{constructor(e,t,s=null,o=null){super(),this.method=e,this.aNode=t,this.bNode=s,this.cNode=o}getInputType(e){const t=this.aNode.getNodeType(e),s=this.bNode?this.bNode.getNodeType(e):null,o=this.cNode?this.cNode.getNodeType(e):null,i=e.isMatrix(t)?0:e.getTypeLength(t),r=e.isMatrix(s)?0:e.getTypeLength(s),a=e.isMatrix(o)?0:e.getTypeLength(o);return i>r&&i>a?t:r>a?s:a>i?o:t}getNodeType(e){const t=this.method;return t===p.LENGTH||t===p.DISTANCE||t===p.DOT?"float":t===p.CROSS?"vec3":t===p.ALL?"bool":t===p.EQUALS?e.changeComponentType(this.aNode.getNodeType(e),"bool"):t===p.MOD?this.aNode.getNodeType(e):this.getInputType(e)}generate(e,t){const s=this.method,o=this.getNodeType(e),i=this.getInputType(e),r=this.aNode,a=this.bNode,c=this.cNode,u=e.renderer.isWebGLRenderer===!0;if(s===p.TRANSFORM_DIRECTION){let l=r,h=a;e.isMatrix(l.getNodeType(e))?h=w(f(h),0):l=w(f(l),0);const d=B(l,h).xyz;return zt(d).build(e,t)}else{if(s===p.NEGATE)return e.format("( - "+r.build(e,i)+" )",o,t);if(s===p.ONE_MINUS)return ze(1,r).build(e,t);if(s===p.RECIPROCAL)return qe(1,r).build(e,t);if(s===p.DIFFERENCE)return _e(ze(r,a)).build(e,t);{const l=[];return s===p.CROSS||s===p.MOD?l.push(r.build(e,o),a.build(e,o)):s===p.STEP?l.push(r.build(e,e.getTypeLength(r.getNodeType(e))===1?"float":i),a.build(e,i)):u&&(s===p.MIN||s===p.MAX)||s===p.MOD?l.push(r.build(e,i),a.build(e,e.getTypeLength(a.getNodeType(e))===1?"float":i)):s===p.REFRACT?l.push(r.build(e,i),a.build(e,i),c.build(e,"float")):s===p.MIX?l.push(r.build(e,i),a.build(e,i),c.build(e,e.getTypeLength(c.getNodeType(e))===1?"float":i)):(l.push(r.build(e,i)),a!==null&&l.push(a.build(e,i)),c!==null&&l.push(c.build(e,i))),e.format(`${e.getMethod(s,o)}( ${l.join(", ")} )`,o,t)}}}serialize(e){super.serialize(e),e.method=this.method}deserialize(e){super.deserialize(e),this.method=e.method}}p.ALL="all";p.ANY="any";p.EQUALS="equals";p.RADIANS="radians";p.DEGREES="degrees";p.EXP="exp";p.EXP2="exp2";p.LOG="log";p.LOG2="log2";p.SQRT="sqrt";p.INVERSE_SQRT="inversesqrt";p.FLOOR="floor";p.CEIL="ceil";p.NORMALIZE="normalize";p.FRACT="fract";p.SIN="sin";p.COS="cos";p.TAN="tan";p.ASIN="asin";p.ACOS="acos";p.ATAN="atan";p.ABS="abs";p.SIGN="sign";p.LENGTH="length";p.NEGATE="negate";p.ONE_MINUS="oneMinus";p.DFDX="dFdx";p.DFDY="dFdy";p.ROUND="round";p.RECIPROCAL="reciprocal";p.TRUNC="trunc";p.FWIDTH="fwidth";p.BITCAST="bitcast";p.TRANSPOSE="transpose";p.ATAN2="atan2";p.MIN="min";p.MAX="max";p.MOD="mod";p.STEP="step";p.REFLECT="reflect";p.DISTANCE="distance";p.DIFFERENCE="difference";p.DOT="dot";p.CROSS="cross";p.POW="pow";p.TRANSFORM_DIRECTION="transformDirection";p.MIX="mix";p.CLAMP="clamp";p.REFRACT="refract";p.SMOOTHSTEP="smoothstep";p.FACEFORWARD="faceforward";const ui=y(1e-6);y(1e6);const to=y(Math.PI);y(Math.PI*2);const li=g(p,p.ALL),Yc=g(p,p.ANY),Kc=g(p,p.EQUALS),Jc=g(p,p.RADIANS),Qc=g(p,p.DEGREES),di=g(p,p.EXP),on=g(p,p.EXP2),hi=g(p,p.LOG),Ss=g(p,p.LOG2),eu=g(p,p.SQRT),tu=g(p,p.INVERSE_SQRT),Ms=g(p,p.FLOOR),pi=g(p,p.CEIL),zt=g(p,p.NORMALIZE),As=g(p,p.FRACT),Me=g(p,p.SIN),Oe=g(p,p.COS),su=g(p,p.TAN),nu=g(p,p.ASIN),ou=g(p,p.ACOS),iu=g(p,p.ATAN),_e=g(p,p.ABS),Dn=g(p,p.SIGN),xt=g(p,p.LENGTH),ru=g(p,p.NEGATE),au=g(p,p.ONE_MINUS),cu=g(p,p.DFDX),uu=g(p,p.DFDY),lu=g(p,p.ROUND),du=g(p,p.RECIPROCAL),hu=g(p,p.TRUNC),pu=g(p,p.FWIDTH);g(p,p.BITCAST);const mu=g(p,p.TRANSPOSE),gu=g(p,p.ATAN2),He=g(p,p.MIN),pe=g(p,p.MAX),fu=g(p,p.MOD),Nu=g(p,p.STEP),yu=g(p,p.REFLECT),Tu=g(p,p.DISTANCE),xu=g(p,p.DIFFERENCE),Rs=g(p,p.DOT),mi=g(p,p.CROSS),$e=g(p,p.POW),gi=g(p,p.POW,2),vu=g(p,p.POW,3),Su=g(p,p.POW,4),Mu=g(p,p.TRANSFORM_DIRECTION),Au=n=>B(Dn(n),$e(_e(n),1/3)),Ru=n=>Rs(n,n),Q=g(p,p.MIX),nt=(n,e=0,t=1)=>M(new p(p.CLAMP,M(n),M(e),M(t))),Cu=n=>nt(n),fi=g(p,p.REFRACT),Fe=g(p,p.SMOOTHSTEP),wu=g(p,p.FACEFORWARD),Eu=(n,e,t)=>Q(e,t,n),Iu=(n,e,t)=>Fe(e,t,n);m("all",li);m("any",Yc);m("equals",Kc);m("radians",Jc);m("degrees",Qc);m("exp",di);m("exp2",on);m("log",hi);m("log2",Ss);m("sqrt",eu);m("inverseSqrt",tu);m("floor",Ms);m("ceil",pi);m("normalize",zt);m("fract",As);m("sin",Me);m("cos",Oe);m("tan",su);m("asin",nu);m("acos",ou);m("atan",iu);m("abs",_e);m("sign",Dn);m("length",xt);m("lengthSq",Ru);m("negate",ru);m("oneMinus",au);m("dFdx",cu);m("dFdy",uu);m("round",lu);m("reciprocal",du);m("trunc",hu);m("fwidth",pu);m("atan2",gu);m("min",He);m("max",pe);m("mod",fu);m("step",Nu);m("reflect",yu);m("distance",Tu);m("dot",Rs);m("cross",mi);m("pow",$e);m("pow2",gi);m("pow3",vu);m("pow4",Su);m("transformDirection",Mu);m("mix",Eu);m("clamp",nt);m("refract",fi);m("smoothstep",Iu);m("faceForward",wu);m("difference",xu);m("saturate",Cu);m("cbrt",Au);m("transpose",mu);T("MathNode",p);const Lu=A(n=>{const{value:e}=n,{rgb:t}=e,s=t.mul(.9478672986).add(.0521327014).pow(2.4),o=t.mul(.0773993808),i=t.lessThanEqual(.04045),r=Q(s,o,i);return w(r,e.a)}),Vu=A(n=>{const{value:e}=n,{rgb:t}=e,s=t.pow(.41666).mul(1.055).sub(.055),o=t.mul(12.92),i=t.lessThanEqual(.0031308),r=Q(s,o,i);return w(r,e.a)}),so=n=>{let e=null;return n===xn?e="Linear":n===Qr&&(e="sRGB"),e},Ni=(n,e)=>so(n)+"To"+so(e);class Te extends P{constructor(e,t){super("vec4"),this.method=e,this.node=t}setup(){const{method:e,node:t}=this;return e===Te.LINEAR_TO_LINEAR?t:Ou[e]({value:t})}}Te.LINEAR_TO_LINEAR="LinearToLinear";Te.LINEAR_TO_sRGB="LinearTosRGB";Te.sRGB_TO_LINEAR="sRGBToLinear";const Ou={[Te.LINEAR_TO_sRGB]:Vu,[Te.sRGB_TO_LINEAR]:Lu},_u=(n,e)=>M(new Te(Ni(xn,e),M(n))),yi=(n,e)=>M(new Te(Ni(e,xn),M(n))),bu=g(Te,Te.LINEAR_TO_sRGB),Du=g(Te,Te.sRGB_TO_LINEAR);m("linearTosRGB",bu);m("sRGBToLinear",Du);m("linearToColorSpace",_u);m("colorSpaceToLinear",yi);T("ColorSpaceNode",Te);class Ti extends V{constructor(e="",t="void"){super(t),this.snippet=e}generate(e,t){const s=this.getNodeType(e),o=this.snippet;if(s==="void")e.addLineFlowCode(o);else return e.format(`( ${o} )`,s,t)}}const Cs=g(Ti);T("ExpressionNode",Ti);class xi extends rt{constructor(e){super(0),this.textureNode=e,this.updateType=z.FRAME}get texture(){return this.textureNode.value}update(){const e=this.texture,t=e.images,s=t&&t.length>0?t[0]&&t[0].image||t[0]:e.image;if(s&&s.width!==void 0){const{width:o,height:i}=s;this.value=Math.log2(Math.max(o,i))}}}const zu=g(xi);T("MaxMipLevelNode",xi);class at extends rt{constructor(e,t=null,s=null){super(e),this.isTextureNode=!0,this.uvNode=t,this.levelNode=s,this.compareNode=null,this.depthNode=null,this.gradNode=null,this.sampler=!0,this.updateMatrix=!1,this.updateType=z.NONE,this.referenceNode=null,this._value=e,this.setUpdateMatrix(t===null)}set value(e){this.referenceNode?this.referenceNode.value=e:this._value=e}get value(){return this.referenceNode?this.referenceNode.value:this._value}getUniformHash(){return this.value.uuid}getNodeType(){return this.value.isDepthTexture===!0?"float":this.value.type===ea?"uvec4":this.value.type===ta?"ivec4":"vec4"}getInputType(){return"texture"}getDefaultUV(){return xe(this.value.channel)}updateReference(){return this.value}getTransformedUV(e){const t=this.value;return O(t.matrix).mul(f(e,1)).xy}setUpdateMatrix(e){return this.updateMatrix=e,this.updateType=e?z.FRAME:z.NONE,this}setupUV(e,t){const s=this.value;return e.isFlipY()&&(s.isRenderTargetTexture===!0||s.isFramebufferTexture===!0||s.isDepthTexture===!0)&&(t=t.setY(t.y.oneMinus())),t}setup(e){const t=e.getNodeProperties(this);let s=this.uvNode;(s===null||e.context.forceUVContext===!0)&&e.context.getUV&&(s=e.context.getUV(this)),s||(s=this.getDefaultUV()),this.updateMatrix===!0&&(s=this.getTransformedUV(s)),s=this.setupUV(e,s);let o=this.levelNode;o===null&&e.context.getTextureLevel&&(o=e.context.getTextureLevel(this)),t.uvNode=s,t.levelNode=o,t.compareNode=this.compareNode,t.gradNode=this.gradNode,t.depthNode=this.depthNode}generateUV(e,t){return t.build(e,this.sampler===!0?"vec2":"ivec2")}generateSnippet(e,t,s,o,i,r,a){const c=this.value;let u;return o?u=e.generateTextureLevel(c,t,s,o,i):a?u=e.generateTextureGrad(c,t,s,a,i):r?u=e.generateTextureCompare(c,t,s,r,i):this.sampler===!1?u=e.generateTextureLoad(c,t,s,i):u=e.generateTexture(c,t,s,i),u}generate(e,t){const s=e.getNodeProperties(this),o=this.value;if(!o||o.isTexture!==!0)throw new Error("TextureNode: Need a three.js texture.");const i=super.generate(e,"property");if(t==="sampler")return i+"_sampler";if(e.isReference(t))return i;{const r=e.getDataFromNode(this);let a=r.propertyName;if(a===void 0){const{uvNode:l,levelNode:h,compareNode:d,depthNode:x,gradNode:v}=s,C=this.generateUV(e,l),E=h?h.build(e,"float"):null,L=x?x.build(e,"int"):null,b=d?d.build(e,"float"):null,I=v?[v[0].build(e,"vec2"),v[1].build(e,"vec2")]:null,Y=e.getVarFromNode(this);a=e.getPropertyName(Y);const W=this.generateSnippet(e,i,C,E,L,b,I);e.addLineFlowCode(`${a} = ${W}`),r.snippet=W,r.propertyName=a}let c=a;const u=this.getNodeType(e);return e.needsColorSpaceToLinear(o)&&(c=yi(Cs(c,u),o.colorSpace).setup(e).build(e,u)),e.format(c,u,t)}}setSampler(e){return this.sampler=e,this}getSampler(){return this.sampler}uv(e){const t=this.clone();return t.uvNode=e,t.referenceNode=this,M(t)}blur(e){const t=this.clone();return t.levelNode=e.mul(zu(t)),t.referenceNode=this,M(t)}level(e){const t=this.clone();return t.levelNode=e,t.referenceNode=this,t}size(e){return ds(this,e)}compare(e){const t=this.clone();return t.compareNode=M(e),t.referenceNode=this,M(t)}grad(e,t){const s=this.clone();return s.gradNode=[M(e),M(t)],s.referenceNode=this,M(s)}depth(e){const t=this.clone();return t.depthNode=M(e),t.referenceNode=this,M(t)}serialize(e){super.serialize(e),e.value=this.value.toJSON(e.meta).uuid}deserialize(e){super.deserialize(e),this.value=e.meta.textures[e.value]}update(){const e=this.value;e.matrixAutoUpdate===!0&&e.updateMatrix()}clone(){const e=new this.constructor(this.value,this.uvNode,this.levelNode);return e.sampler=this.sampler,e}}const oe=g(at),ke=(...n)=>oe(...n).setSampler(!1);m("texture",oe);T("TextureNode",at);class ws extends rt{constructor(e,t,s=0){super(e,t),this.isBufferNode=!0,this.bufferType=t,this.bufferCount=s}getElementType(e){return this.getNodeType(e)}getInputType(){return"buffer"}}const zn=(n,e,t)=>M(new ws(n,e,t));T("BufferNode",ws);class Fu extends At{constructor(e,t){super(e,t),this.isArrayBufferElementNode=!0}getNodeType(e){return this.node.getElementType(e)}generate(e){const t=super.generate(e),s=this.getNodeType();return e.format(t,"vec4",s)}}class vi extends ws{constructor(e,t=null){super(null,"vec4"),this.array=e,this.elementType=t,this._elementType=null,this._elementLength=0,this.updateType=z.RENDER,this.isArrayBufferNode=!0}getElementType(){return this.elementType||this._elementType}getElementLength(){return this._elementLength}update(){const{array:e,value:t}=this,s=this.getElementLength(),o=this.getElementType();if(s===1)for(let i=0;i<e.length;i++){const r=i*4;t[r]=e[i]}else if(o==="color")for(let i=0;i<e.length;i++){const r=i*4,a=e[i];t[r]=a.r,t[r+1]=a.g,t[r+2]=a.b||0}else for(let i=0;i<e.length;i++){const r=i*4,a=e[i];t[r]=a.x,t[r+1]=a.y,t[r+2]=a.z||0,t[r+3]=a.w||0}}setup(e){const t=this.array.length;this._elementType=this.elementType===null?je(this.array[0]):this.elementType,this._elementLength=e.getTypeLength(this._elementType);let s=Float32Array;return this._elementType.charAt(0)==="i"?s=Int32Array:this._elementType.charAt(0)==="u"&&(s=Uint32Array),this.value=new s(t*4),this.bufferCount=t,this.bufferType=e.changeComponentType("vec4",e.getComponentType(this._elementType)),super.setup(e)}element(e){return M(new Fu(this,M(e)))}}const rn=(n,e)=>M(new vi(n,e));T("UniformsNode",vi);class Pu extends At{constructor(e,t){super(e,t),this.referenceNode=e,this.isReferenceElementNode=!0}getNodeType(){return this.referenceNode.uniformType}generate(e){const t=super.generate(e),s=this.referenceNode.getNodeType(),o=this.getNodeType();return e.format(t,s,o)}}class Rt extends V{constructor(e,t,s=null,o=null){super(),this.property=e,this.uniformType=t,this.object=s,this.count=o,this.properties=e.split("."),this.reference=null,this.node=null,this.updateType=z.OBJECT}element(e){return M(new Pu(this,M(e)))}setNodeType(e){let t=null;this.count!==null?t=zn(null,e,this.count):Array.isArray(this.getValueFromReference())?t=rn(null,e):e==="texture"?t=oe(null):t=O(null,e),this.node=t}getNodeType(e){return this.node===null&&this.updateValue(),this.node.getNodeType(e)}getValueFromReference(e=this.reference){const{properties:t}=this;let s=e[t[0]];for(let o=1;o<t.length;o++)s=s[t[o]];return s}updateReference(e){return this.reference=this.object!==null?this.object:e.object,this.reference}setup(){return this.updateValue(),this.node}update(){this.updateValue()}updateValue(){this.node===null&&this.setNodeType(this.uniformType);const e=this.getValueFromReference();Array.isArray(e)?this.node.array=e:this.node.value=e}}const Ce=(n,e,t)=>M(new Rt(n,e,t)),Uu=(n,e,t,s)=>M(new Rt(n,e,s,t));T("ReferenceNode",Rt);class Si extends Rt{constructor(e,t,s=null){super(e,t,s),this.material=s}updateReference(e){return this.reference=this.material!==null?this.material:e.material,this.reference}}const We=(n,e,t)=>M(new Si(n,e,t));T("MaterialReferenceNode",Si);const ct=bn("camera").onRenderUpdate(()=>{ct.needsUpdate=!0}),wt=O("float").label("cameraNear").setGroup(ct).onRenderUpdate(({camera:n})=>n.near),Et=O("float").label("cameraFar").setGroup(ct).onRenderUpdate(({camera:n})=>n.far),Bu=O("float").label("cameraLogDepth").setGroup(ct).onRenderUpdate(({camera:n})=>2/(Math.log(n.far+1)/Math.LN2)),be=O("mat4").label("cameraProjectionMatrix").setGroup(ct).onRenderUpdate(({camera:n})=>n.projectionMatrix),Ct=O("mat4").label("cameraViewMatrix").setGroup(ct).onRenderUpdate(({camera:n})=>n.matrixWorldInverse),Mi=O(new me).label("cameraPosition").setGroup(ct).onRenderUpdate(({camera:n},e)=>e.value.setFromMatrixPosition(n.matrixWorld));class _ extends V{constructor(e=_.VIEW_MATRIX,t=null){super(),this.scope=e,this.object3d=t,this.updateType=z.OBJECT,this._uniformNode=new rt(null)}getNodeType(){const e=this.scope;if(e===_.WORLD_MATRIX||e===_.VIEW_MATRIX)return"mat4";if(e===_.NORMAL_MATRIX)return"mat3";if(e===_.POSITION||e===_.VIEW_POSITION||e===_.DIRECTION||e===_.SCALE)return"vec3"}update(e){const t=this.object3d,s=this._uniformNode,o=this.scope;if(o===_.VIEW_MATRIX)s.value=t.modelViewMatrix;else if(o===_.NORMAL_MATRIX)s.value=t.normalMatrix;else if(o===_.WORLD_MATRIX)s.value=t.matrixWorld;else if(o===_.POSITION)s.value=s.value||new me,s.value.setFromMatrixPosition(t.matrixWorld);else if(o===_.SCALE)s.value=s.value||new me,s.value.setFromMatrixScale(t.matrixWorld);else if(o===_.DIRECTION)s.value=s.value||new me,t.getWorldDirection(s.value);else if(o===_.VIEW_POSITION){const i=e.camera;s.value=s.value||new me,s.value.setFromMatrixPosition(t.matrixWorld),s.value.applyMatrix4(i.matrixWorldInverse)}}generate(e){const t=this.scope;return t===_.WORLD_MATRIX||t===_.VIEW_MATRIX?this._uniformNode.nodeType="mat4":t===_.NORMAL_MATRIX?this._uniformNode.nodeType="mat3":(t===_.POSITION||t===_.VIEW_POSITION||t===_.DIRECTION||t===_.SCALE)&&(this._uniformNode.nodeType="vec3"),this._uniformNode.build(e)}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}_.VIEW_MATRIX="viewMatrix";_.NORMAL_MATRIX="normalMatrix";_.WORLD_MATRIX="worldMatrix";_.POSITION="position";_.SCALE="scale";_.VIEW_POSITION="viewPosition";_.DIRECTION="direction";g(_,_.DIRECTION);g(_,_.VIEW_MATRIX);g(_,_.NORMAL_MATRIX);g(_,_.WORLD_MATRIX);const an=g(_,_.POSITION);g(_,_.SCALE);const Fn=g(_,_.VIEW_POSITION);T("Object3DNode",_);class re extends _{constructor(e=re.VIEW_MATRIX){super(e)}update(e){this.object3d=e.object,super.update(e)}}R(re,re.DIRECTION);const ot=R(re,re.VIEW_MATRIX).label("modelViewMatrix").temp("ModelViewMatrix"),Ai=R(re,re.NORMAL_MATRIX),Ft=R(re,re.WORLD_MATRIX);R(re,re.POSITION);R(re,re.SCALE);R(re,re.VIEW_POSITION);const ku=O(new kt).onObjectUpdate(({object:n},e)=>e.value.copy(n.matrixWorld).invert());T("ModelNode",re);const hs=ae("normal","vec3",f(0,1,0)),Le=hs.toVar("normalLocal"),Ke=J(Ai.mul(Le),"v_normalView").normalize().toVar("normalView"),Gu=J(Ke.transformDirection(Ct),"v_normalWorld").normalize().toVar("transformedNormalWorld"),Z=j("vec3","transformedNormalView"),Ri=Z.transformDirection(Ct).normalize().toVar("transformedNormalWorld"),mt=j("vec3","transformedClearcoatNormalView"),no=new Map;class N extends V{constructor(e){super(),this.scope=e}getCache(e,t){let s=no.get(e);return s===void 0&&(s=We(e,t),no.set(e,s)),s}getFloat(e){return this.getCache(e,"float")}getColor(e){return this.getCache(e,"color")}getTexture(e){return this.getCache(e==="map"?"map":e+"Map","texture")}setup(e){const t=e.context.material,s=this.scope;let o=null;if(s===N.COLOR){const i=this.getColor(s);t.map&&t.map.isTexture===!0?o=i.mul(this.getTexture("map")):o=i}else if(s===N.OPACITY){const i=this.getFloat(s);t.alphaMap&&t.alphaMap.isTexture===!0?o=i.mul(this.getTexture("alpha")):o=i}else if(s===N.SPECULAR_STRENGTH)t.specularMap&&t.specularMap.isTexture===!0?o=this.getTexture("specular").r:o=y(1);else if(s===N.SPECULAR_INTENSITY){const i=this.getFloat(s);t.specularMap?o=i.mul(this.getTexture(s).a):o=i}else if(s===N.SPECULAR_COLOR){const i=this.getColor(s);t.specularColorMap&&t.specularColorMap.isTexture===!0?o=i.mul(this.getTexture(s).rgb):o=i}else if(s===N.ROUGHNESS){const i=this.getFloat(s);t.roughnessMap&&t.roughnessMap.isTexture===!0?o=i.mul(this.getTexture(s).g):o=i}else if(s===N.METALNESS){const i=this.getFloat(s);t.metalnessMap&&t.metalnessMap.isTexture===!0?o=i.mul(this.getTexture(s).b):o=i}else if(s===N.EMISSIVE){const i=this.getColor(s);t.emissiveMap&&t.emissiveMap.isTexture===!0?o=i.mul(this.getTexture(s)):o=i}else if(s===N.NORMAL)t.normalMap?o=this.getTexture("normal").normalMap(this.getCache("normalScale","vec2")):t.bumpMap?o=this.getTexture("bump").r.bumpMap(this.getFloat("bumpScale")):o=Ke;else if(s===N.CLEARCOAT){const i=this.getFloat(s);t.clearcoatMap&&t.clearcoatMap.isTexture===!0?o=i.mul(this.getTexture(s).r):o=i}else if(s===N.CLEARCOAT_ROUGHNESS){const i=this.getFloat(s);t.clearcoatRoughnessMap&&t.clearcoatRoughnessMap.isTexture===!0?o=i.mul(this.getTexture(s).r):o=i}else if(s===N.CLEARCOAT_NORMAL)t.clearcoatNormalMap?o=this.getTexture(s).normalMap(this.getCache(s+"Scale","vec2")):o=Ke;else if(s===N.SHEEN){const i=this.getColor("sheenColor").mul(this.getFloat("sheen"));t.sheenColorMap&&t.sheenColorMap.isTexture===!0?o=i.mul(this.getTexture("sheenColor").rgb):o=i}else if(s===N.SHEEN_ROUGHNESS){const i=this.getFloat(s);t.sheenRoughnessMap&&t.sheenRoughnessMap.isTexture===!0?o=i.mul(this.getTexture(s).a):o=i,o=o.clamp(.07,1)}else if(s===N.ANISOTROPY)if(t.anisotropyMap&&t.anisotropyMap.isTexture===!0){const i=this.getTexture(s);o=Cn(It.x,It.y,It.y.negate(),It.x).mul(i.rg.mul(2).sub(S(1)).normalize().mul(i.b))}else o=It;else if(s===N.IRIDESCENCE_THICKNESS){const i=Ce("1","float",t.iridescenceThicknessRange);if(t.iridescenceThicknessMap){const r=Ce("0","float",t.iridescenceThicknessRange);o=i.sub(r).mul(this.getTexture(s).g).add(r)}else o=i}else if(s===N.TRANSMISSION){const i=this.getFloat(s);t.transmissionMap?o=i.mul(this.getTexture(s).r):o=i}else if(s===N.THICKNESS){const i=this.getFloat(s);t.thicknessMap?o=i.mul(this.getTexture(s).g):o=i}else if(s===N.IOR)o=this.getFloat(s);else{const i=this.getNodeType(e);o=this.getCache(s,i)}return o}}N.ALPHA_TEST="alphaTest";N.COLOR="color";N.OPACITY="opacity";N.SHININESS="shininess";N.SPECULAR="specular";N.SPECULAR_STRENGTH="specularStrength";N.SPECULAR_INTENSITY="specularIntensity";N.SPECULAR_COLOR="specularColor";N.REFLECTIVITY="reflectivity";N.ROUGHNESS="roughness";N.METALNESS="metalness";N.NORMAL="normal";N.CLEARCOAT="clearcoat";N.CLEARCOAT_ROUGHNESS="clearcoatRoughness";N.CLEARCOAT_NORMAL="clearcoatNormal";N.EMISSIVE="emissive";N.ROTATION="rotation";N.SHEEN="sheen";N.SHEEN_ROUGHNESS="sheenRoughness";N.ANISOTROPY="anisotropy";N.IRIDESCENCE="iridescence";N.IRIDESCENCE_IOR="iridescenceIOR";N.IRIDESCENCE_THICKNESS="iridescenceThickness";N.IOR="ior";N.TRANSMISSION="transmission";N.THICKNESS="thickness";N.ATTENUATION_DISTANCE="attenuationDistance";N.ATTENUATION_COLOR="attenuationColor";N.LINE_SCALE="scale";N.LINE_DASH_SIZE="dashSize";N.LINE_GAP_SIZE="gapSize";N.LINE_WIDTH="linewidth";N.LINE_DASH_OFFSET="dashOffset";N.POINT_WIDTH="pointWidth";N.DISPERSION="dispersion";const Hu=R(N,N.ALPHA_TEST),Pt=R(N,N.COLOR),$u=R(N,N.SHININESS),Wu=R(N,N.EMISSIVE),Ci=R(N,N.OPACITY),qu=R(N,N.SPECULAR),oo=R(N,N.SPECULAR_INTENSITY),Xu=R(N,N.SPECULAR_COLOR),ju=R(N,N.SPECULAR_STRENGTH);R(N,N.REFLECTIVITY);const Zu=R(N,N.ROUGHNESS),Yu=R(N,N.METALNESS),Ku=R(N,N.NORMAL),Ju=R(N,N.CLEARCOAT),Qu=R(N,N.CLEARCOAT_ROUGHNESS),el=R(N,N.CLEARCOAT_NORMAL),tl=R(N,N.ROTATION),sl=R(N,N.SHEEN),nl=R(N,N.SHEEN_ROUGHNESS),ol=R(N,N.ANISOTROPY),il=R(N,N.IRIDESCENCE),rl=R(N,N.IRIDESCENCE_IOR),al=R(N,N.IRIDESCENCE_THICKNESS),cl=R(N,N.TRANSMISSION),ul=R(N,N.THICKNESS),ll=R(N,N.IOR),dl=R(N,N.ATTENUATION_DISTANCE),hl=R(N,N.ATTENUATION_COLOR),cn=R(N,N.LINE_SCALE),wi=R(N,N.LINE_DASH_SIZE),Ei=R(N,N.LINE_GAP_SIZE),_s=R(N,N.LINE_WIDTH),io=R(N,N.LINE_DASH_OFFSET),pl=R(N,N.POINT_WIDTH),ml=R(N,N.DISPERSION),It=O(new ue).onReference(function(n){return n.material}).onRenderUpdate(function({material:n}){this.value.set(n.anisotropy*Math.cos(n.anisotropyRotation),n.anisotropy*Math.sin(n.anisotropyRotation))});T("MaterialNode",N);const he=ae("position","vec3"),ie=he.toVar("positionLocal"),un=J(Ft.mul(ie).xyz,"v_positionWorld"),gl=J(ie.transformDirection(Ft),"v_positionWorldDirection").normalize().toVar("positionWorldDirection"),ce=J(ot.mul(ie).xyz,"v_positionView"),X=J(ce.negate(),"v_positionViewDirection").normalize().toVar("positionViewDirection");class Ii extends P{constructor(e=null){super("vec4"),this.positionNode=e}setup(e){if(e.shaderStage==="fragment")return J(e.context.mvp);const t=this.positionNode||ie;return be.mul(ot).mul(t)}}const ro=g(Ii);T("ModelViewProjectionNode",Ii);class Li extends Ns{constructor(e,t=null,s=0,o=0){super(e,t),this.isBufferNode=!0,this.bufferType=t,this.bufferStride=s,this.bufferOffset=o,this.usage=sa,this.instanced=!1,this.attribute=null,this.global=!0,e&&e.isBufferAttribute===!0&&(this.attribute=e,this.usage=e.usage,this.instanced=e.isInstancedBufferAttribute)}getHash(e){if(this.bufferStride===0&&this.bufferOffset===0){let t=e.globalCache.getData(this.value);return t===void 0&&(t={node:this},e.globalCache.setData(this.value,t)),t.node.uuid}return this.uuid}getNodeType(e){return this.bufferType===null&&(this.bufferType=e.getTypeFromAttribute(this.attribute)),this.bufferType}setup(e){if(this.attribute!==null)return;const t=this.getNodeType(e),s=this.value,o=e.getTypeLength(t),i=this.bufferStride||o,r=this.bufferOffset,a=s.isInterleavedBuffer===!0?s:new na(s,i),c=new oa(a,o,r);a.setUsage(this.usage),this.attribute=c,this.attribute.isInstancedBufferAttribute=this.instanced}generate(e){const t=this.getNodeType(e),s=e.getBufferAttributeFromNode(this,t),o=e.getPropertyName(s);let i=null;return e.shaderStage==="vertex"||e.shaderStage==="compute"?(this.name=o,i=o):i=J(this).build(e,t),i}getInputType(){return"bufferAttribute"}setUsage(e){return this.usage=e,this.attribute&&this.attribute.isBufferAttribute===!0&&(this.attribute.usage=e),this}setInstanced(e){return this.instanced=e,this}}const Es=(n,e,t,s)=>M(new Li(n,e,t,s)),fl=(n,e,t,s)=>Es(n,e,t,s).setUsage(Ot),ln=(n,e,t,s)=>Es(n,e,t,s).setInstanced(!0),ao=(n,e,t,s)=>fl(n,e,t,s).setInstanced(!0);m("toAttribute",n=>Es(n.value));T("BufferAttributeNode",Li);class Vi extends V{constructor(e){super("void"),this.instanceMesh=e,this.instanceMatrixNode=null,this.instanceColorNode=null,this.updateType=z.FRAME,this.buffer=null,this.bufferColor=null}setup(){let e=this.instanceMatrixNode;const t=this.instanceMesh;if(e===null){const c=t.instanceMatrix,u=new ia(c.array,16,1);this.buffer=u;const l=c.usage===Ot?ao:ln,h=[l(u,"vec4",16,0),l(u,"vec4",16,4),l(u,"vec4",16,8),l(u,"vec4",16,12)];e=Nt(...h),this.instanceMatrixNode=e}const s=t.instanceColor;if(s&&this.instanceColorNode===null){const c=new Do(s.array,3),u=s.usage===Ot?ao:ln;this.bufferColor=c,this.instanceColorNode=f(u(c,"vec3",3,0))}const o=e.mul(ie).xyz,i=le(e[0].xyz,e[1].xyz,e[2].xyz),r=Le.div(f(i[0].dot(i[0]),i[1].dot(i[1]),i[2].dot(i[2]))),a=i.mul(r).xyz;ie.assign(o),Le.assign(a),this.instanceColorNode!==null&&Ve("vec3","vInstanceColor").assign(this.instanceColorNode)}update(){this.instanceMesh.instanceMatrix.usage!==Ot&&this.instanceMesh.instanceMatrix.version!==this.buffer.version&&(this.buffer.version=this.instanceMesh.instanceMatrix.version),this.instanceMesh.instanceColor&&this.instanceMesh.instanceColor.usage!==Ot&&this.instanceMesh.instanceColor.version!==this.bufferColor.version&&(this.bufferColor.version=this.instanceMesh.instanceColor.version)}}const Nl=g(Vi);T("InstanceNode",Vi);const Oi=A((n,e)=>(e.geometry.hasAttribute("tangent")===!1&&e.geometry.computeTangents(),ae("tangent","vec4")))(),Pn=Oi.xyz.toVar("tangentLocal"),_i=J(ot.mul(w(Pn,0)).xyz,"v_tangentView").normalize().toVar("tangentView");class bi extends V{constructor(e){super("void"),this.batchMesh=e,this.instanceColorNode=null,this.batchingIdNode=null}setup(e){this.batchingIdNode===null&&(e.getDrawIndex()===null?this.batchingIdNode=In:this.batchingIdNode=wc);const t=A(([d])=>{const x=ds(ke(this.batchMesh._indirectTexture),0),v=ee(d).remainder(ee(x)),C=ee(d).div(ee(x));return ke(this.batchMesh._indirectTexture,Xe(v,C),null,"uvec4").x}).setLayout({name:"getIndirectIndex",type:"uint",inputs:[{name:"id",type:"int"}]}),s=this.batchMesh._matricesTexture,o=ds(ke(s),0),i=y(t(ee(this.batchingIdNode))).mul(4).toVar(),r=ee(i.mod(o)),a=ee(i).div(ee(o)),c=Nt(ke(s,Xe(r,a)),ke(s,Xe(r.add(1),a)),ke(s,Xe(r.add(2),a)),ke(s,Xe(r.add(3),a))),u=le(c[0].xyz,c[1].xyz,c[2].xyz);ie.assign(c.mul(ie));const l=Le.div(f(u[0].dot(u[0]),u[1].dot(u[1]),u[2].dot(u[2]))),h=u.mul(l).xyz;Le.assign(h),e.hasGeometryAttribute("tangent")&&Pn.mulAssign(u)}}const yl=g(bi);T("batch",bi);class Di extends V{constructor(e,t=!1){super("void"),this.skinnedMesh=e,this.useReference=t,this.updateType=z.OBJECT,this.skinIndexNode=ae("skinIndex","uvec4"),this.skinWeightNode=ae("skinWeight","vec4");let s,o,i;t?(s=Ce("bindMatrix","mat4"),o=Ce("bindMatrixInverse","mat4"),i=Uu("skeleton.boneMatrices","mat4",e.skeleton.bones.length)):(s=O(e.bindMatrix,"mat4"),o=O(e.bindMatrixInverse,"mat4"),i=zn(e.skeleton.boneMatrices,"mat4",e.skeleton.bones.length)),this.bindMatrixNode=s,this.bindMatrixInverseNode=o,this.boneMatricesNode=i}setup(e){const{skinIndexNode:t,skinWeightNode:s,bindMatrixNode:o,bindMatrixInverseNode:i,boneMatricesNode:r}=this,a=r.element(t.x),c=r.element(t.y),u=r.element(t.z),l=r.element(t.w),h=o.mul(ie),d=ye(a.mul(s.x).mul(h),c.mul(s.y).mul(h),u.mul(s.z).mul(h),l.mul(s.w).mul(h)),x=i.mul(d).xyz;let v=ye(s.x.mul(a),s.y.mul(c),s.z.mul(u),s.w.mul(l));v=i.mul(v).mul(o);const C=v.transformDirection(Le).xyz;ie.assign(x),Le.assign(C),e.hasGeometryAttribute("tangent")&&Pn.assign(C)}generate(e,t){if(t!=="void")return ie.build(e,t)}update(e){(this.useReference?e.object:this.skinnedMesh).skeleton.update()}}const Tl=n=>M(new Di(n,!0));T("SkinningNode",Di);class zi extends V{constructor(e=[]){super(),this.params=e}getVarName(e){return String.fromCharCode(105+e)}getProperties(e){const t=e.getNodeProperties(this);if(t.stackNode!==void 0)return t;const s={};for(let i=0,r=this.params.length-1;i<r;i++){const a=this.params[i],c=a.isNode!==!0&&a.name||this.getVarName(i),u=a.isNode!==!0&&a.type||"int";s[c]=Cs(c,u)}const o=e.addStack();return t.returnsNode=this.params[this.params.length-1](s,o,e),t.stackNode=o,e.removeStack(),t}getNodeType(e){const{returnsNode:t}=this.getProperties(e);return t?t.getNodeType(e):"void"}setup(e){this.getProperties(e)}generate(e){const t=this.getProperties(e),s=this.params,o=t.stackNode;for(let a=0,c=s.length-1;a<c;a++){const u=s[a];let l=null,h=null,d=null,x=null,v=null,C=null;u.isNode?(x="int",d=this.getVarName(a),l="0",h=u.build(e,x),v="<"):(x=u.type||"int",d=u.name||this.getVarName(a),l=u.start,h=u.end,v=u.condition,C=u.update,typeof l=="number"?l=l.toString():l&&l.isNode&&(l=l.build(e,x)),typeof h=="number"?h=h.toString():h&&h.isNode&&(h=h.build(e,x)),l!==void 0&&h===void 0?(l=l+" - 1",h="0",v=">="):h!==void 0&&l===void 0&&(l="0",v="<"),v===void 0&&(Number(l)>Number(h)?v=">=":v="<"));const E={start:l,end:h,condition:v},L=E.start,b=E.end;let I="",Y="",W="";C||(x==="int"||x==="uint"?v.includes("<")?C="++":C="--":v.includes("<")?C="+= 1.":C="-= 1."),I+=e.getVar(x,d)+" = "+L,Y+=d+" "+v+" "+b,W+=d+" "+C;const G=`for ( ${I}; ${Y}; ${W} )`;e.addFlowCode((a===0?`
`:"")+e.tab+G+` {

`).addFlowTab()}const i=o.build(e,"void"),r=t.returnsNode?t.returnsNode.build(e):"";e.removeFlowTab().addFlowCode(`
`+e.tab+i);for(let a=0,c=this.params.length-1;a<c;a++)e.addFlowCode((a===0?"":e.tab)+`}

`).removeFlowTab();return e.addFlowTab(),r}}const Ee=(...n)=>M(new zi(ft(n,"int"))).append(),Fi=()=>Cs("break").append();m("loop",(n,...e)=>Qo(n,Ee(...e)));T("LoopNode",zi);const bs=new WeakMap,ve=new Ze,co=A(({bufferMap:n,influence:e,stride:t,width:s,depth:o,offset:i})=>{const r=ee(Cc).mul(t).add(i),a=r.div(s),c=r.sub(a.mul(s));return ke(n,Xe(c,a)).depth(o).mul(e)});function xl(n){const e=n.morphAttributes.position!==void 0,t=n.morphAttributes.normal!==void 0,s=n.morphAttributes.color!==void 0,o=n.morphAttributes.position||n.morphAttributes.normal||n.morphAttributes.color,i=o!==void 0?o.length:0;let r=bs.get(n);if(r===void 0||r.count!==i){let L=function(){C.dispose(),bs.delete(n),n.removeEventListener("dispose",L)};r!==void 0&&r.texture.dispose();const a=n.morphAttributes.position||[],c=n.morphAttributes.normal||[],u=n.morphAttributes.color||[];let l=0;e===!0&&(l=1),t===!0&&(l=2),s===!0&&(l=3);let h=n.attributes.position.count*l,d=1;const x=4096;h>x&&(d=Math.ceil(h/x),h=x);const v=new Float32Array(h*d*4*i),C=new ra(v,h,d,i);C.type=aa,C.needsUpdate=!0;const E=l*4;for(let b=0;b<i;b++){const I=a[b],Y=c[b],W=u[b],G=h*d*4*b;for(let $=0;$<I.count;$++){const D=$*E;e===!0&&(ve.fromBufferAttribute(I,$),v[G+D+0]=ve.x,v[G+D+1]=ve.y,v[G+D+2]=ve.z,v[G+D+3]=0),t===!0&&(ve.fromBufferAttribute(Y,$),v[G+D+4]=ve.x,v[G+D+5]=ve.y,v[G+D+6]=ve.z,v[G+D+7]=0),s===!0&&(ve.fromBufferAttribute(W,$),v[G+D+8]=ve.x,v[G+D+9]=ve.y,v[G+D+10]=ve.z,v[G+D+11]=W.itemSize===4?ve.w:1)}}r={count:i,texture:C,stride:l,size:new ue(h,d)},bs.set(n,r),n.addEventListener("dispose",L)}return r}class Pi extends V{constructor(e){super("void"),this.mesh=e,this.morphBaseInfluence=O(1),this.updateType=z.OBJECT}setup(e){const{geometry:t}=e,s=t.morphAttributes.position!==void 0,o=t.morphAttributes.normal!==void 0,i=t.morphAttributes.position||t.morphAttributes.normal||t.morphAttributes.color,r=i!==void 0?i.length:0,{texture:a,stride:c,size:u}=xl(t);s===!0&&ie.mulAssign(this.morphBaseInfluence),o===!0&&Le.mulAssign(this.morphBaseInfluence);const l=ee(u.width);Ee(r,({i:h})=>{const d=y(0).toVar();this.mesh.count>1&&this.mesh.morphTexture!==null&&this.mesh.morphTexture!==void 0?d.assign(ke(this.mesh.morphTexture,Xe(ee(h).add(1),ee(In))).r):d.assign(Ce("morphTargetInfluences","float").element(h).toVar()),s===!0&&ie.addAssign(co({bufferMap:a,influence:d,stride:c,width:l,depth:h,offset:ee(0)})),o===!0&&Le.addAssign(co({bufferMap:a,influence:d,stride:c,width:l,depth:h,offset:ee(1)}))})}update(){const e=this.morphBaseInfluence;this.mesh.geometry.morphTargetsRelative?e.value=1:e.value=1-this.mesh.morphTargetInfluences.reduce((t,s)=>t+s,0)}}const vl=g(Pi);T("MorphNode",Pi);const Sl=X.negate().reflect(Z),Ml=Sl.transformDirection(Ct).toVar("reflectVector");class Ui extends at{constructor(e,t=null,s=null){super(e,t,s),this.isCubeTextureNode=!0}getInputType(){return"cubeTexture"}getDefaultUV(){return Ml}setUpdateMatrix(){}setupUV(e,t){const s=this.value;return e.renderer.coordinateSystem===zo||!s.isRenderTargetTexture?f(t.x.negate(),t.yz):t}generateUV(e,t){return t.build(e,"vec3")}}const Bi=g(Ui);m("cubeTexture",Bi);T("CubeTextureNode",Ui);class Gt extends V{constructor(){super("vec3")}generate(){console.warn("Abstract function.")}}T("LightingNode",Gt);let Lt=null;class Qe extends Gt{constructor(e=null){super(),this.updateType=z.FRAME,this.light=e,this.rtt=null,this.shadowNode=null,this.shadowMaskNode=null,this.color=new Tn,this._defaultColorNode=O(this.color),this.colorNode=this._defaultColorNode,this.isAnalyticLightNode=!0}getCacheKey(){return super.getCacheKey()+"-"+(this.light.id+"-"+(this.light.castShadow?"1":"0"))}getHash(){return this.light.uuid}setupShadow(e){const{object:t}=e;if(t.receiveShadow===!1)return;let s=this.shadowNode;if(s===null){Lt===null&&(Lt=e.createNodeMaterial(),Lt.fragmentNode=w(0,0,0,1),Lt.isShadowNodeMaterial=!0);const o=this.light.shadow,i=e.createRenderTarget(o.mapSize.width,o.mapSize.height),r=new vn;r.minFilter=$n,r.magFilter=$n,r.image.width=o.mapSize.width,r.image.height=o.mapSize.height,r.compareFunction=ca,i.depthTexture=r,o.camera.updateProjectionMatrix();const a=Ce("intensity","float",o),c=Ce("bias","float",o),u=Ce("normalBias","float",o),l=t.material.shadowPositionNode||un;let h=O(o.matrix).mul(l.add(Gu.mul(u)));h=h.xyz.div(h.w);const d=h.x.greaterThanEqual(0).and(h.x.lessThanEqual(1)).and(h.y.greaterThanEqual(0)).and(h.y.lessThanEqual(1)).and(h.z.lessThanEqual(1));let x=h.z.add(c);e.renderer.coordinateSystem===zo&&(x=x.mul(2).sub(1)),h=f(h.x,h.y.oneMinus(),x),s=((L,b,I)=>oe(L,b).compare(I))(r,h.xy,h.z);const C=oe(i.texture,h),E=d.mix(1,s.mix(C.a.mix(1,C),1));this.rtt=i,this.colorNode=this.colorNode.mul(Q(1,E,a)),this.shadowNode=s,this.shadowMaskNode=E,this.updateBeforeType=z.RENDER}}setup(e){this.light.castShadow?this.setupShadow(e):this.shadowNode!==null&&this.disposeShadow()}updateShadow(e){const{rtt:t,light:s}=this,{renderer:o,scene:i,camera:r}=e,a=i.overrideMaterial;i.overrideMaterial=Lt,t.setSize(s.shadow.mapSize.width,s.shadow.mapSize.height),s.shadow.updateMatrices(s),s.shadow.camera.layers.mask=r.layers.mask;const c=o.toneMapping,u=o.getRenderTarget(),l=o.getRenderObjectFunction();o.setRenderObjectFunction((h,...d)=>{h.castShadow===!0&&o.renderObject(h,...d)}),o.setRenderTarget(t),o.toneMapping=Dt,o.render(i,s.shadow.camera),o.setRenderTarget(u),o.setRenderObjectFunction(l),o.toneMapping=c,i.overrideMaterial=a}disposeShadow(){this.rtt.dispose(),this.shadowNode=null,this.shadowMaskNode=null,this.rtt=null,this.colorNode=this._defaultColorNode}updateBefore(e){const{light:t}=this;t.castShadow&&this.updateShadow(e)}update(){const{light:e}=this;this.color.copy(e.color).multiplyScalar(e.intensity)}}T("AnalyticLightNode",Qe);const ps=new WeakMap,Al=n=>n.sort((e,t)=>e.id-t.id);class Rl extends V{constructor(e=[]){super("vec3"),this.totalDiffuseNode=f().temp("totalDiffuse"),this.totalSpecularNode=f().temp("totalSpecular"),this.outgoingLightNode=f().temp("outgoingLight"),this.lightNodes=e,this._hash=null}get hasLight(){return this.lightNodes.length>0}getHash(){if(this._hash===null){const e=[];for(const t of this.lightNodes)e.push(t.getHash());this._hash="lights-"+e.join(",")}return this._hash}analyze(e){const t=e.getDataFromNode(this);for(const s of t.nodes)s.build(e)}setup(e){const t=e.context,s=t.lightingModel;let o=this.outgoingLightNode;if(s){const{lightNodes:i,totalDiffuseNode:r,totalSpecularNode:a}=this;t.outgoingLight=o;const c=e.addStack(),u=e.getDataFromNode(this);u.nodes=c.nodes,s.start(t,c,e);for(const L of i)L.build(e);s.indirectDiffuse(t,c,e),s.indirectSpecular(t,c,e),s.ambientOcclusion(t,c,e);const{backdrop:l,backdropAlpha:h}=t,{directDiffuse:d,directSpecular:x,indirectDiffuse:v,indirectSpecular:C}=t.reflectedLight;let E=d.add(v);l!==null&&(h!==null?E=f(h.mix(E,l)):E=f(l),t.material.transparent=!0),r.assign(E),a.assign(x.add(C)),o.assign(r.add(a)),s.finish(t,c,e),o=o.bypass(e.removeStack())}return o}_getLightNodeById(e){for(const t of this.lightNodes)if(t.isAnalyticLightNode&&t.light.id===e)return t;return null}fromLights(e=[]){const t=[];e=Al(e);for(const s of e){let o=this._getLightNodeById(s.id);if(o===null){const i=s.constructor,r=ps.has(i)?ps.get(i):Qe;o=M(new r(s))}t.push(o)}return this.lightNodes=t,this._hash=null,this}}const Cl=g(Rl);function ut(n,e){if(ps.has(n)){console.warn(`Redefinition of light node ${e.type}`);return}if(typeof n!="function")throw new Error(`Light ${n.name} is not a class`);if(typeof e!="function"||!e.type)throw new Error(`Light node ${e.type} is not a class`);ps.set(n,e)}class ki extends Gt{constructor(e=null){super(),this.aoNode=e}setup(e){const s=this.aoNode.x.sub(1).mul(1).add(1);e.context.ambientOcclusion.mulAssign(s)}}T("AONode",ki);class Gi extends En{constructor(e,t=null,s=null,o=null){super(e),this.lightingModel=t,this.backdropNode=s,this.backdropAlphaNode=o,this._context=null}getContext(){const{backdropNode:e,backdropAlphaNode:t}=this,s=f().temp("directDiffuse"),o=f().temp("directSpecular"),i=f().temp("indirectDiffuse"),r=f().temp("indirectSpecular"),a={directDiffuse:s,directSpecular:o,indirectDiffuse:i,indirectSpecular:r};return{radiance:f().temp("radiance"),irradiance:f().temp("irradiance"),iblIrradiance:f().temp("iblIrradiance"),ambientOcclusion:y(1).temp("ambientOcclusion"),reflectedLight:a,backdrop:e,backdropAlpha:t}}setup(e){return this.context=this._context||(this._context=this.getContext()),this.context.lightingModel=this.lightingModel||e.context.lightingModel,super.setup(e)}}const Hi=g(Gi);m("lightingContext",Hi);T("LightingContextNode",Gi);const wl=n=>n.mul(Oi.w).xyz,El=J(wl(Ke.cross(_i)),"v_bitangentView").normalize().toVar("bitangentView"),gt=le(_i,El,Ke);X.mul(gt);const Il=(()=>{let n=yt.cross(X);return n=n.cross(yt).normalize(),n=Q(n,Z,st.mul(Ge.oneMinus()).oneMinus().pow2().pow2()).normalize(),n})();class Un extends V{constructor(e,t,s=null){super(),this.condNode=e,this.ifNode=t,this.elseNode=s}getNodeType(e){const t=this.ifNode.getNodeType(e);if(this.elseNode!==null){const s=this.elseNode.getNodeType(e);if(e.getTypeLength(s)>e.getTypeLength(t))return s}return t}setup(e){const t=e.getNodeProperties(this);t.condNode=this.condNode.cache(),t.ifNode=this.ifNode.cache(),t.elseNode=this.elseNode?this.elseNode.cache():null}generate(e,t){const s=this.getNodeType(e),o=e.getDataFromNode(this);if(o.nodeProperty!==void 0)return o.nodeProperty;const{condNode:i,ifNode:r,elseNode:a}=e.getNodeProperties(this),c=t!=="void",u=c?j(s).build(e):"";o.nodeProperty=u;const l=i.build(e,"bool");e.addFlowCode(`
${e.tab}if ( ${l} ) {

`).addFlowTab();let h=r.build(e,s);if(h&&(c?h=u+" = "+h+";":h="return "+h+";"),e.removeFlowTab().addFlowCode(e.tab+"	"+h+`

`+e.tab+"}"),a!==null){e.addFlowCode(` else {

`).addFlowTab();let d=a.build(e,s);d&&(c?d=u+" = "+d+";":d="return "+d+";"),e.removeFlowTab().addFlowCode(e.tab+"	"+d+`

`+e.tab+`}

`)}else e.addFlowCode(`

`);return e.format(u,s,t)}}const Re=g(Un);m("cond",Re);T("CondNode",Un);const uo=y(1),dn=y(-2),jt=y(.8),Ds=y(-1),Zt=y(.4),zs=y(2),Yt=y(.305),Fs=y(3),lo=y(.21),Ll=y(4),ho=y(4),Vl=y(16),Ol=A(([n])=>{const e=f(_e(n)).toVar(),t=y(-1).toVar();return K(e.x.greaterThan(e.z),()=>{K(e.x.greaterThan(e.y),()=>{t.assign(Re(n.x.greaterThan(0),0,3))}).else(()=>{t.assign(Re(n.y.greaterThan(0),1,4))})}).else(()=>{K(e.z.greaterThan(e.y),()=>{t.assign(Re(n.z.greaterThan(0),2,5))}).else(()=>{t.assign(Re(n.y.greaterThan(0),1,4))})}),t}).setLayout({name:"getFace",type:"float",inputs:[{name:"direction",type:"vec3"}]}),_l=A(([n,e])=>{const t=S().toVar();return K(e.equal(0),()=>{t.assign(S(n.z,n.y).div(_e(n.x)))}).elseif(e.equal(1),()=>{t.assign(S(n.x.negate(),n.z.negate()).div(_e(n.y)))}).elseif(e.equal(2),()=>{t.assign(S(n.x.negate(),n.y).div(_e(n.z)))}).elseif(e.equal(3),()=>{t.assign(S(n.z.negate(),n.y).div(_e(n.x)))}).elseif(e.equal(4),()=>{t.assign(S(n.x.negate(),n.z).div(_e(n.y)))}).else(()=>{t.assign(S(n.x,n.y).div(_e(n.z)))}),B(.5,t.add(1))}).setLayout({name:"getUV",type:"vec2",inputs:[{name:"direction",type:"vec3"},{name:"face",type:"float"}]}),bl=A(([n])=>{const e=y(0).toVar();return K(n.greaterThanEqual(jt),()=>{e.assign(uo.sub(n).mul(Ds.sub(dn)).div(uo.sub(jt)).add(dn))}).elseif(n.greaterThanEqual(Zt),()=>{e.assign(jt.sub(n).mul(zs.sub(Ds)).div(jt.sub(Zt)).add(Ds))}).elseif(n.greaterThanEqual(Yt),()=>{e.assign(Zt.sub(n).mul(Fs.sub(zs)).div(Zt.sub(Yt)).add(zs))}).elseif(n.greaterThanEqual(lo),()=>{e.assign(Yt.sub(n).mul(Ll.sub(Fs)).div(Yt.sub(lo)).add(Fs))}).else(()=>{e.assign(y(-2).mul(Ss(B(1.16,n))))}),e}).setLayout({name:"roughnessToMip",type:"float",inputs:[{name:"roughness",type:"float"}]});A(([n,e])=>{const t=n.toVar();t.assign(B(2,t).sub(1));const s=f(t,1).toVar();return K(e.equal(0),()=>{s.assign(s.zyx)}).elseif(e.equal(1),()=>{s.assign(s.xzy),s.xz.mulAssign(-1)}).elseif(e.equal(2),()=>{s.x.mulAssign(-1)}).elseif(e.equal(3),()=>{s.assign(s.zyx),s.xz.mulAssign(-1)}).elseif(e.equal(4),()=>{s.assign(s.xzy),s.xy.mulAssign(-1)}).elseif(e.equal(5),()=>{s.z.mulAssign(-1)}),s}).setLayout({name:"getDirection",type:"vec3",inputs:[{name:"uv",type:"vec2"},{name:"face",type:"float"}]});const Dl=A(([n,e,t,s,o,i])=>{const r=y(t),a=f(e),c=nt(bl(r),dn,i),u=As(c),l=Ms(c),h=f(hn(n,a,l,s,o,i)).toVar();return K(u.notEqual(0),()=>{const d=f(hn(n,a,l.add(1),s,o,i)).toVar();h.assign(Q(h,d,u))}),h}),hn=A(([n,e,t,s,o,i])=>{const r=y(t).toVar(),a=f(e),c=y(Ol(a)).toVar(),u=y(pe(ho.sub(r),0)).toVar();r.assign(pe(r,ho));const l=y(on(r)).toVar(),h=S(_l(a,c).mul(l.sub(2)).add(1)).toVar();return K(c.greaterThan(2),()=>{h.y.addAssign(l),c.subAssign(3)}),h.x.addAssign(c.mul(l)),h.x.addAssign(u.mul(B(3,Vl))),h.y.addAssign(B(4,on(i).sub(l))),h.x.mulAssign(s),h.y.mulAssign(o),n.uv(h).grad(S(),S())}),Ps=A(({envMap:n,mipInt:e,outputDirection:t,theta:s,axis:o,CUBEUV_TEXEL_WIDTH:i,CUBEUV_TEXEL_HEIGHT:r,CUBEUV_MAX_MIP:a})=>{const c=Oe(s),u=t.mul(c).add(o.cross(t).mul(Me(s))).add(o.mul(o.dot(t).mul(c.oneMinus())));return hn(n,u,e,i,r,a)});A(({n,latitudinal:e,poleAxis:t,outputDirection:s,weights:o,samples:i,dTheta:r,mipInt:a,envMap:c,CUBEUV_TEXEL_WIDTH:u,CUBEUV_TEXEL_HEIGHT:l,CUBEUV_MAX_MIP:h})=>{const d=f(Re(e,t,mi(t,s))).toVar();K(li(d.equals(f(0))),()=>{d.assign(f(s.z,0,s.x.negate()))}),d.assign(zt(d));const x=f().toVar();return x.addAssign(o.element(ee(0)).mul(Ps({theta:0,axis:d,outputDirection:s,mipInt:a,envMap:c,CUBEUV_TEXEL_WIDTH:u,CUBEUV_TEXEL_HEIGHT:l,CUBEUV_MAX_MIP:h}))),Ee({start:ee(1),end:n},({i:v})=>{K(v.greaterThanEqual(i),()=>{Fi()});const C=y(r.mul(y(v))).toVar();x.addAssign(o.element(v).mul(Ps({theta:C.mul(-1),axis:d,outputDirection:s,mipInt:a,envMap:c,CUBEUV_TEXEL_WIDTH:u,CUBEUV_TEXEL_HEIGHT:l,CUBEUV_MAX_MIP:h}))),x.addAssign(o.element(v).mul(Ps({theta:C,axis:d,outputDirection:s,mipInt:a,envMap:c,CUBEUV_TEXEL_WIDTH:u,CUBEUV_TEXEL_HEIGHT:l,CUBEUV_MAX_MIP:h})))}),w(x,1)});let ms=null;const po=new WeakMap;function zl(n){const e=Math.log2(n)-2,t=1/n;return{texelWidth:1/(3*Math.max(Math.pow(2,e),7*16)),texelHeight:t,maxMip:e}}function Fl(n){let e=po.get(n);if((e!==void 0?e.pmremVersion:-1)!==n.pmremVersion){if(n.isCubeTexture){if(n.source.data.some(s=>s===void 0))throw new Error("PMREMNode: Undefined texture in CubeTexture. Use onLoad callback or async loader");e=ms.fromCubemap(n,e)}else{if(n.image===void 0)throw new Error("PMREMNode: Undefined image in Texture. Use onLoad callback or async loader");e=ms.fromEquirectangular(n,e)}e.pmremVersion=n.pmremVersion,po.set(n,e)}return e.texture}class $i extends P{constructor(e,t=null,s=null){super("vec3"),this._value=e,this._pmrem=null,this.uvNode=t,this.levelNode=s,this._generator=null,this._texture=oe(null),this._width=O(0),this._height=O(0),this._maxMip=O(0),this.updateBeforeType=z.RENDER}set value(e){this._value=e,this._pmrem=null}get value(){return this._value}updateFromTexture(e){const t=zl(e.image.height);this._texture.value=e,this._width.value=t.texelWidth,this._height.value=t.texelHeight,this._maxMip.value=t.maxMip}updateBefore(){let e=this._pmrem;const t=e?e.pmremVersion:-1,s=this._value;t!==s.pmremVersion&&(s.isPMREMTexture===!0?e=s:e=Fl(s),this._pmrem=e,this.updateFromTexture(e))}setup(e){ms===null&&(ms=e.createPMREMGenerator()),this.updateBefore(e);let t=this.uvNode;t===null&&e.context.getUV&&(t=e.context.getUV(this));const s=this.value;e.renderer.coordinateSystem===Fo&&s.isPMREMTexture!==!0&&s.isRenderTargetTexture===!0&&(t=f(t.x.negate(),t.yz));let o=this.levelNode;return o===null&&e.context.getTextureLevel&&(o=e.context.getTextureLevel(this)),Dl(this._texture,t,o,this._width,this._height,this._maxMip)}}const Pl=g($i);T("PMREMNode",$i);const mo=new WeakMap;class Wi extends Gt{constructor(e=null){super(),this.envNode=e}setup(e){let t=this.envNode;if(t.isTextureNode){let x=mo.get(t.value);x===void 0&&(x=Pl(t.value),mo.set(t.value,x)),t=x}const{material:s}=e,i=s.envMap?Ce("envMapIntensity","float",e.material):Ce("environmentIntensity","float",e.scene),a=s.useAnisotropy===!0||s.anisotropy>0?Il:Z,c=bt(t,go(Ge,a)).mul(i),u=bt(t,Ul(Ri)).mul(Math.PI).mul(i),l=es(c),h=es(u);e.context.radiance.addAssign(l),e.context.iblIrradiance.addAssign(h);const d=e.context.lightingModel.clearcoatRadiance;if(d){const x=bt(t,go(cs,mt)).mul(i),v=es(x);d.addAssign(v)}}}const go=(n,e)=>{let t=null;return{getUV:()=>(t===null&&(t=X.negate().reflect(e),t=n.mul(n).mix(t,e).normalize(),t=t.transformDirection(Ct)),t),getTextureLevel:()=>n}},Ul=n=>({getUV:()=>n,getTextureLevel:()=>y(1)});T("EnvironmentNode",Wi);class qi extends Gt{constructor(e){super(),this.node=e}setup(e){e.context.irradiance.addAssign(this.node)}}T("IrradianceNode",qi);let Us,Bs;class F extends V{constructor(e){super(),this.scope=e,this.isViewportNode=!0}getNodeType(){return this.scope===F.VIEWPORT?"vec4":this.scope===F.COORDINATE?"vec3":"vec2"}getUpdateType(){let e=z.NONE;return(this.scope===F.RESOLUTION||this.scope===F.VIEWPORT)&&(e=z.RENDER),this.updateType=e,e}update({renderer:e}){this.scope===F.VIEWPORT?e.getViewport(Bs):e.getDrawingBufferSize(Us)}setup(){const e=this.scope;let t=null;if(e===F.RESOLUTION)t=O(Us||(Us=new ue));else if(e===F.VIEWPORT)t=O(Bs||(Bs=new Ze));else{t=Bl.div(pn);let s=t.x,o=t.y;/bottom/i.test(e)&&(o=o.oneMinus()),/right/i.test(e)&&(s=s.oneMinus()),t=S(s,o)}return t}generate(e){if(this.scope===F.COORDINATE){let t=e.getFragCoord();if(e.isFlipY()){const s=e.getNodeProperties(pn).outputNode.build(e);t=`${e.getType("vec3")}( ${t}.x, ${s}.y - ${t}.y, ${t}.z )`}return t}return super.generate(e)}}F.COORDINATE="coordinate";F.RESOLUTION="resolution";F.VIEWPORT="viewport";F.TOP_LEFT="topLeft";F.BOTTOM_LEFT="bottomLeft";F.TOP_RIGHT="topRight";F.BOTTOM_RIGHT="bottomRight";const Bl=R(F,F.COORDINATE),pn=R(F,F.RESOLUTION),vt=R(F,F.VIEWPORT),Ut=R(F,F.TOP_LEFT);R(F,F.BOTTOM_LEFT);R(F,F.TOP_RIGHT);R(F,F.BOTTOM_RIGHT);T("ViewportNode",F);const Vt=new ue;class Ht extends at{constructor(e=Ut,t=null,s=null){s===null&&(s=new Po,s.minFilter=ua),super(s,e,t),this.generateMipmaps=!1,this.isOutputTextureNode=!0,this.updateBeforeType=z.FRAME}updateBefore(e){const t=e.renderer;t.getDrawingBufferSize(Vt);const s=this.value;(s.image.width!==Vt.width||s.image.height!==Vt.height)&&(s.image.width=Vt.width,s.image.height=Vt.height,s.needsUpdate=!0);const o=s.generateMipmaps;s.generateMipmaps=this.generateMipmaps,t.copyFramebufferToTexture(s),s.generateMipmaps=o}clone(){const e=new this.constructor(this.uvNode,this.levelNode,this.value);return e.generateMipmaps=this.generateMipmaps,e}}const kl=g(Ht),Xi=g(Ht,null,null,{generateMipmaps:!0});m("viewportTexture",kl);m("viewportMipTexture",Xi);T("ViewportTextureNode",Ht);let ks=null;class ji extends Ht{constructor(e=Ut,t=null){ks===null&&(ks=new vn),super(e,t,ks)}}const Zi=g(ji);m("viewportDepthTexture",Zi);T("ViewportDepthTextureNode",ji);class Ae extends V{constructor(e,t=null){super("float"),this.scope=e,this.valueNode=t,this.isViewportDepthNode=!0}generate(e){const{scope:t}=this;return t===Ae.DEPTH?e.getFragDepth():super.generate(e)}setup({camera:e}){const{scope:t}=this,s=this.valueNode;let o=null;if(t===Ae.DEPTH)s!==null?o=Ki().assign(s):e.isPerspectiveCamera?o=Gl(ce.z,wt,Et):o=ns(ce.z,wt,Et);else if(t===Ae.LINEAR_DEPTH)if(s!==null)if(e.isPerspectiveCamera){const i=Yi(s,wt,Et);o=ns(i,wt,Et)}else o=s;else o=ns(ce.z,wt,Et);return o}}const ns=(n,e,t)=>n.add(e).div(e.sub(t)),Gl=(n,e,t)=>e.add(n).mul(t).div(t.sub(e).mul(n)),Yi=(n,e,t)=>e.mul(t).div(t.sub(e).mul(n).sub(t));Ae.DEPTH="depth";Ae.LINEAR_DEPTH="linearDepth";const Ki=g(Ae,Ae.DEPTH),Ji=R(Ae,Ae.DEPTH),Hl=g(Ae,Ae.LINEAR_DEPTH);Hl(Zi());Ji.assign=n=>Ki(n);T("ViewportDepthNode",Ae);class Je extends V{constructor(e=Je.DEFAULT){super(),this.scope=e}setup(e){super.setup(e);const t=e.clippingContext,{localClipIntersection:s,localClippingCount:o,globalClippingCount:i}=t,r=i+o,a=s?r-o:r;return this.scope===Je.ALPHA_TO_COVERAGE?this.setupAlphaToCoverage(t.planes,r,a):this.setupDefault(t.planes,r,a)}setupAlphaToCoverage(e,t,s){return A(()=>{const o=rn(e),i=j("float","distanceToPlane"),r=j("float","distanceToGradient"),a=j("float","clipOpacity");a.assign(1);let c;if(Ee(s,({i:u})=>{c=o.element(u),i.assign(ce.dot(c.xyz).negate().add(c.w)),r.assign(i.fwidth().div(2)),a.mulAssign(Fe(r.negate(),r,i)),a.equal(0).discard()}),s<t){const u=j("float","unionclipOpacity");u.assign(1),Ee({start:s,end:t},({i:l})=>{c=o.element(l),i.assign(ce.dot(c.xyz).negate().add(c.w)),r.assign(i.fwidth().div(2)),u.mulAssign(Fe(r.negate(),r,i).oneMinus())}),a.mulAssign(u.oneMinus())}H.a.mulAssign(a),H.a.equal(0).discard()})()}setupDefault(e,t,s){return A(()=>{const o=rn(e);let i;if(Ee(s,({i:r})=>{i=o.element(r),ce.dot(i.xyz).greaterThan(i.w).discard()}),s<t){const r=j("bool","clipped");r.assign(!0),Ee({start:s,end:t},({i:a})=>{i=o.element(a),r.assign(ce.dot(i.xyz).greaterThan(i.w).and(r))}),r.discard()}})()}}Je.ALPHA_TO_COVERAGE="alphaToCoverage";Je.DEFAULT="default";const $l=()=>M(new Je),Wl=()=>M(new Je(Je.ALPHA_TO_COVERAGE));class Qi extends V{constructor(){super("bool"),this.isFrontFacingNode=!0}generate(e){const{renderer:t,material:s}=e;return t.coordinateSystem===Fo&&s.side===la?"false":e.getFrontFacing()}}const ql=R(Qi),gs=y(ql).mul(2).sub(1);T("FrontFacingNode",Qi);const mn=new Map;class de extends Wn{constructor(){super(),this.isNodeMaterial=!0,this.type=this.constructor.type,this.forceSinglePass=!1,this.fog=!0,this.lights=!0,this.normals=!0,this.lightsNode=null,this.envNode=null,this.aoNode=null,this.colorNode=null,this.normalNode=null,this.opacityNode=null,this.backdropNode=null,this.backdropAlphaNode=null,this.alphaTestNode=null,this.positionNode=null,this.depthNode=null,this.shadowNode=null,this.shadowPositionNode=null,this.outputNode=null,this.fragmentNode=null,this.vertexNode=null}customProgramCacheKey(){return this.type+Go(this)}build(e){this.setup(e)}setup(e){e.addStack(),e.stack.outputNode=this.vertexNode||this.setupPosition(e),e.addFlow("vertex",e.removeStack()),e.addStack();let t;const s=this.setupClipping(e);if(this.depthWrite===!0&&this.setupDepth(e),this.fragmentNode===null){this.normals===!0&&this.setupNormal(e),this.setupDiffuseColor(e),this.setupVariants(e);const o=this.setupLighting(e);s!==null&&e.stack.add(s);const i=w(o,H.a).max(0);t=this.setupOutput(e,i),Ec.assign(t),this.outputNode!==null&&(t=this.outputNode)}else{let o=this.fragmentNode;o.isOutputStructNode!==!0&&(o=w(o)),t=this.setupOutput(e,o)}e.stack.outputNode=t,e.addFlow("fragment",e.removeStack())}setupClipping(e){if(e.clippingContext===null)return null;const{globalClippingCount:t,localClippingCount:s}=e.clippingContext;let o=null;return(t||s)&&(this.alphaToCoverage?o=Wl():e.stack.add($l())),o}setupDepth(e){const{renderer:t}=e;let s=this.depthNode;s===null&&t.logarithmicDepthBuffer===!0&&(s=ro().w.add(1).log2().mul(Bu).mul(.5)),s!==null&&Ji.assign(s).append()}setupPosition(e){const{object:t}=e,s=t.geometry;if(e.addStack(),(s.morphAttributes.position||s.morphAttributes.normal||s.morphAttributes.color)&&vl(t).append(),t.isSkinnedMesh===!0&&Tl(t).append(),this.displacementMap){const i=We("displacementMap","texture"),r=We("displacementScale","float"),a=We("displacementBias","float");ie.addAssign(Le.normalize().mul(i.x.mul(r).add(a)))}t.isBatchedMesh&&yl(t).append(),t.instanceMatrix&&t.instanceMatrix.isInstancedBufferAttribute===!0&&Nl(t).append(),this.positionNode!==null&&ie.assign(this.positionNode);const o=ro();return e.context.vertex=e.removeStack(),e.context.mvp=o,o}setupDiffuseColor({object:e,geometry:t}){let s=this.colorNode?w(this.colorNode):Pt;this.vertexColors===!0&&t.hasAttribute("color")&&(s=w(s.xyz.mul(ae("color","vec3")),s.a)),e.instanceColor&&(s=Ve("vec3","vInstanceColor").mul(s)),H.assign(s);const o=this.opacityNode?y(this.opacityNode):Ci;if(H.a.assign(H.a.mul(o)),this.alphaTestNode!==null||this.alphaTest>0){const i=this.alphaTestNode!==null?y(this.alphaTestNode):Hu;H.a.lessThanEqual(i).discard()}this.transparent===!1&&this.blending===da&&this.alphaToCoverage===!1&&H.a.assign(1)}setupVariants(){}setupNormal(){if(this.flatShading===!0){const e=ce.dFdx().cross(ce.dFdy()).normalize();Z.assign(e.mul(gs))}else{const e=this.normalNode?f(this.normalNode):Ku;Z.assign(e.mul(gs))}}getEnvNode(e){let t=null;return this.envNode?t=this.envNode:this.envMap?t=this.envMap.isCubeTexture?Bi(this.envMap):oe(this.envMap):e.environmentNode&&(t=e.environmentNode),t}setupLights(e){const t=this.getEnvNode(e),s=[];if(t&&s.push(new Wi(t)),e.material.lightMap&&s.push(new qi(We("lightMap","texture"))),this.aoNode!==null||e.material.aoMap){const i=this.aoNode!==null?this.aoNode:oe(e.material.aoMap);s.push(new ki(i))}let o=this.lightsNode||e.lightsNode;return s.length>0&&(o=Cl([...o.lightNodes,...s])),o}setupLightingModel(){}setupLighting(e){const{material:t}=e,{backdropNode:s,backdropAlphaNode:o,emissiveNode:i}=this,a=this.lights===!0||this.lightsNode!==null?this.setupLights(e):null;let c=H.rgb;if(a&&a.hasLight!==!1){const u=this.setupLightingModel(e);c=Hi(a,u,s,o)}else s!==null&&(c=f(o!==null?Q(c,s,o):s));return(i&&i.isNode===!0||t.emissive&&t.emissive.isColor===!0)&&(c=c.add(f(i||Wu))),c}setupOutput(e,t){if(this.fog===!0){const s=e.fogNode;s&&(t=w(s.mix(t.rgb,s.colorNode),t.a))}return t}setDefaultValues(e){for(const s in e){const o=e[s];this[s]===void 0&&(this[s]=o,o&&o.clone&&(this[s]=o.clone()))}const t=Object.getOwnPropertyDescriptors(e.constructor.prototype);for(const s in t)Object.getOwnPropertyDescriptor(this.constructor.prototype,s)===void 0&&t[s].get!==void 0&&Object.defineProperty(this.constructor.prototype,s,t[s])}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{},nodes:{}});const s=Wn.prototype.toJSON.call(this,e),o=is(this);s.inputNodes={};for(const{property:r,childNode:a}of o)s.inputNodes[r]=a.toJSON(e).uuid;function i(r){const a=[];for(const c in r){const u=r[c];delete u.metadata,a.push(u)}return a}if(t){const r=i(e.textures),a=i(e.images),c=i(e.nodes);r.length>0&&(s.textures=r),a.length>0&&(s.images=a),c.length>0&&(s.nodes=c)}return s}copy(e){return this.lightsNode=e.lightsNode,this.envNode=e.envNode,this.colorNode=e.colorNode,this.normalNode=e.normalNode,this.opacityNode=e.opacityNode,this.backdropNode=e.backdropNode,this.backdropAlphaNode=e.backdropAlphaNode,this.alphaTestNode=e.alphaTestNode,this.positionNode=e.positionNode,this.depthNode=e.depthNode,this.shadowNode=e.shadowNode,this.shadowPositionNode=e.shadowPositionNode,this.outputNode=e.outputNode,this.fragmentNode=e.fragmentNode,this.vertexNode=e.vertexNode,super.copy(e)}static fromMaterial(e){if(e.isNodeMaterial===!0)return e;const t=e.type.replace("Material","NodeMaterial"),s=Xl(t);if(s===void 0)throw new Error(`NodeMaterial: Material "${e.type}" is not compatible.`);for(const o in e)s[o]=e[o];return s}}function ne(n,e){if(typeof e!="function"||!n)throw new Error(`Node material ${n} is not a class`);if(mn.has(n)){console.warn(`Redefinition of node material ${n}`);return}mn.set(n,e),e.type=n}function Xl(n){const e=mn.get(n);if(e!==void 0)return new e}ne("NodeMaterial",de);class er extends V{constructor(e=null){super(),this.nodes=[],this.outputNode=null,this.parent=e,this._currentCond=null,this.isStackNode=!0}getNodeType(e){return this.outputNode?this.outputNode.getNodeType(e):"void"}add(e){return this.nodes.push(e),this}if(e,t){const s=new _t(t);return this._currentCond=Re(e,s),this.add(this._currentCond)}elseif(e,t){const s=new _t(t),o=Re(e,s);return this._currentCond.elseNode=o,this._currentCond=o,this}else(e){return this._currentCond.elseNode=new _t(e),this}build(e,...t){const s=ec();eo(this);for(const o of this.nodes)o.build(e,"void");return eo(s),this.outputNode?this.outputNode.build(e,...t):super.build(e,...t)}}g(er);T("StackNode",er);class tr extends P{constructor(e=gl){super("vec2"),this.dirNode=e}setup(){const e=this.dirNode,t=e.z.atan2(e.x).mul(1/(Math.PI*2)).add(.5),s=e.y.clamp(-1,1).asin().mul(1/Math.PI).add(.5);return S(t,s)}}g(tr);T("EquirectUVNode",tr);class sr extends V{constructor(e){super(),this.types=e,this.isStructTypeNode=!0}getMemberTypes(){return this.types}}T("StructTypeNode",sr);class nr extends V{constructor(...e){super(),this.members=e,this.isOutputStructNode=!0}setup(e){super.setup(e);const t=this.members,s=[];for(let o=0;o<t.length;o++)s.push(t[o].getNodeType(e));this.nodeType=e.getStructTypeFromNode(new sr(s)).name}generate(e,t){const s=e.getOutputStructName(),o=this.members,i=s!==""?s+".":"";for(let r=0;r<o.length;r++){const a=o[r].build(e,t);e.addLineFlowCode(`${i}m${r} = ${a}`)}return s}}g(nr);T("OutputStructNode",nr);class or extends V{constructor(e){super(),this.seedNode=e}setup(){const e=this.seedNode.toUint().mul(747796405).add(2891336453),t=e.shiftRight(e.shiftRight(28).add(4)).bitXor(e).mul(277803737);return t.shiftRight(22).bitXor(t).toFloat().mul(1/2**32)}}const jl=g(or);m("hash",jl);T("HashNode",or);const gn=(n,e)=>$e(B(4,n.mul(ze(1,n))),e),Zl=(n,e)=>n.lessThan(.5)?gn(n.mul(2),e).div(2):ze(1,gn(B(ze(1,n),2),e).div(2)),Yl=(n,e,t)=>$e(qe($e(n,e),ye($e(n,e),$e(ze(1,n),t))),1/e),Kl=(n,e)=>Me(to.mul(e.mul(n).sub(1))).div(to.mul(e.mul(n).sub(1)));m("parabola",gn);m("gain",Zl);m("pcurve",Yl);m("sinc",Kl);const De=A(([n])=>n.fract().sub(.5).abs()),ir=A(([n])=>f(De(n.z.add(De(n.y.mul(1)))),De(n.z.add(De(n.x.mul(1)))),De(n.y.add(De(n.x.mul(1)))))),Jl=A(([n,e,t])=>{const s=f(n).toVar(),o=y(1.4).toVar(),i=y(0).toVar(),r=f(s).toVar();return Ee({start:y(0),end:y(3),type:"float",condition:"<="},()=>{const a=f(ir(r.mul(2))).toVar();s.addAssign(a.add(t.mul(y(.1).mul(e)))),r.mulAssign(1.8),o.mulAssign(1.5),s.mulAssign(1.2);const c=y(De(s.z.add(De(s.x.add(De(s.y)))))).toVar();i.addAssign(c.div(o)),r.addAssign(.14)}),i});De.setLayout({name:"tri",type:"float",inputs:[{name:"x",type:"float"}]});ir.setLayout({name:"tri3",type:"vec3",inputs:[{name:"p",type:"vec3"}]});Jl.setLayout({name:"triNoise3D",type:"float",inputs:[{name:"p",type:"vec3"},{name:"spd",type:"float"},{name:"time",type:"float"}]});let Gs;class rr extends Un{constructor(e){Gs=Gs||Cs("discard"),super(e,Gs)}}const Ql=g(rr),ed=n=>Ql(n).append();m("discard",ed);T("DiscardNode",rr);class ar extends V{constructor(e=[],...t){super(),this.functionNodes=e,this.parametersNodes=t,this._candidateFnCall=null,this.global=!0}getNodeType(){return this.functionNodes[0].shaderNode.layout.type}setup(e){const t=this.parametersNodes;let s=this._candidateFnCall;if(s===null){let o=null,i=-1;for(const r of this.functionNodes){const c=r.shaderNode.layout;if(c===null)throw new Error("FunctionOverloadingNode: FunctionNode must be a layout.");const u=c.inputs;if(t.length===u.length){let l=0;for(let h=0;h<t.length;h++){const d=t[h],x=u[h];d.getNodeType(e)===x.type?l++:l=0}l>i&&(o=r,i=l)}}this._candidateFnCall=s=o(...t)}return s}}g(ar);T("FunctionOverloadingNode",ar);class cr extends P{constructor(){super("vec2")}setup(){const e=f(X.z,0,X.x.negate()).normalize(),t=X.cross(e);return S(e.dot(Z),t.dot(Z)).mul(.495).add(.5)}}const td=R(cr);T("MatcapUVNode",cr);class ge extends rt{constructor(e=ge.LOCAL,t=1,s=0){super(s),this.scope=e,this.scale=t,this.updateType=z.FRAME}update(e){const t=this.scope,s=this.scale;t===ge.LOCAL?this.value+=e.deltaTime*s:t===ge.DELTA?this.value=e.deltaTime*s:t===ge.FRAME?this.value=e.frameId:this.value=e.time*s}serialize(e){super.serialize(e),e.scope=this.scope,e.scale=this.scale}deserialize(e){super.deserialize(e),this.scope=e.scope,this.scale=e.scale}}ge.LOCAL="local";ge.GLOBAL="global";ge.DELTA="delta";ge.FRAME="frame";const sd=(n,e=0)=>M(new ge(ge.LOCAL,n,e));R(ge,ge.FRAME).toUint();T("TimerNode",ge);class te extends V{constructor(e=te.SINE,t=sd()){super(),this.method=e,this.timeNode=t}getNodeType(e){return this.timeNode.getNodeType(e)}setup(){const e=this.method,t=M(this.timeNode);let s=null;return e===te.SINE?s=t.add(.75).mul(Math.PI*2).sin().mul(.5).add(.5):e===te.SQUARE?s=t.fract().round():e===te.TRIANGLE?s=t.add(.5).fract().mul(2).sub(1).abs():e===te.SAWTOOTH&&(s=t.fract()),s}serialize(e){super.serialize(e),e.method=this.method}deserialize(e){super.deserialize(e),this.method=e.method}}te.SINE="sine";te.SQUARE="square";te.TRIANGLE="triangle";te.SAWTOOTH="sawtooth";g(te,te.SINE);g(te,te.SQUARE);g(te,te.TRIANGLE);g(te,te.SAWTOOTH);T("OscNode",te);class Pe extends P{constructor(e,t){super(),this.scope=e,this.node=t}getNodeType(e){return this.node.getNodeType(e)}setup(){const{scope:e,node:t}=this;let s=null;return e===Pe.DIRECTION_TO_COLOR?s=t.mul(.5).add(.5):e===Pe.COLOR_TO_DIRECTION&&(s=t.mul(2).sub(1)),s}}Pe.DIRECTION_TO_COLOR="directionToColor";Pe.COLOR_TO_DIRECTION="colorToDirection";const ur=g(Pe,Pe.DIRECTION_TO_COLOR),nd=g(Pe,Pe.COLOR_TO_DIRECTION);m("directionToColor",ur);m("colorToDirection",nd);T("PackingNode",Pe);class Bn extends V{constructor(e,t,s,o=y(0),i=y(1)){super(),this.node=e,this.inLowNode=t,this.inHighNode=s,this.outLowNode=o,this.outHighNode=i,this.doClamp=!0}setup(){const{node:e,inLowNode:t,inHighNode:s,outLowNode:o,outHighNode:i,doClamp:r}=this;let a=e.sub(t).div(s.sub(t));return r===!0&&(a=a.clamp()),a.mul(i.sub(o)).add(o)}}const od=g(Bn,null,null,{doClamp:!1}),id=g(Bn);m("remap",od);m("remapClamp",id);T("RemapNode",Bn);class lr extends P{constructor(e,t,s=S(.5)){super("vec2"),this.uvNode=e,this.rotationNode=t,this.centerNode=s}setup(){const{uvNode:e,rotationNode:t,centerNode:s}=this;return e.sub(s).rotate(t).add(s)}}const rd=g(lr);m("rotateUV",rd);T("RotateUVNode",lr);class dr extends P{constructor(e,t){super(),this.positionNode=e,this.rotationNode=t}getNodeType(e){return this.positionNode.getNodeType(e)}setup(e){const{rotationNode:t,positionNode:s}=this;if(this.getNodeType(e)==="vec2"){const i=t.cos(),r=t.sin();return Cn(i,r,r.negate(),i).mul(s)}else{const i=t,r=Nt(w(1,0,0,0),w(0,Oe(i.x),Me(i.x).negate(),0),w(0,Me(i.x),Oe(i.x),0),w(0,0,0,1)),a=Nt(w(Oe(i.y),0,Me(i.y),0),w(0,1,0,0),w(Me(i.y).negate(),0,Oe(i.y),0),w(0,0,0,1)),c=Nt(w(Oe(i.z),Me(i.z).negate(),0,0),w(Me(i.z),Oe(i.z),0,0),w(0,0,1,0),w(0,0,0,1));return r.mul(a).mul(c).mul(w(s,1)).xyz}}}const ad=g(dr);m("rotate",ad);T("RotateNode",dr);class hr extends V{constructor(e,t=xe(),s=y(0)){super("vec2"),this.countNode=e,this.uvNode=t,this.frameNode=s}setup(){const{frameNode:e,uvNode:t,countNode:s}=this,{width:o,height:i}=s,r=e.mod(o.mul(i)).floor(),a=r.mod(o),c=i.sub(r.add(1).div(o).ceil()),u=s.reciprocal(),l=S(a,c);return t.add(l).mul(u)}}g(hr);T("SpriteSheetUVNode",hr);class pr extends At{constructor(e,t){super(e,t),this.isStorageArrayElementNode=!0}set storageBufferNode(e){this.node=e}get storageBufferNode(){return this.node}setup(e){return e.isAvailable("storageBuffer")===!1&&!this.node.instanceIndex&&this.node.bufferObject===!0&&e.setupPBO(this.node),super.setup(e)}generate(e,t){let s;const o=e.context.assign;if(e.isAvailable("storageBuffer")===!1){const{node:i}=this;!i.instanceIndex&&this.node.bufferObject===!0&&o!==!0?s=e.generatePBO(this):s=i.build(e)}else s=super.generate(e);if(o!==!0){const i=this.getNodeType(e);s=e.format(s,i,t)}return s}}const mr=g(pr);m("storageElement",mr);T("StorageArrayElementNode",pr);class gr extends V{constructor(e,t=null,s=null,o=y(1),i=ie,r=Le){super("vec4"),this.textureXNode=e,this.textureYNode=t,this.textureZNode=s,this.scaleNode=o,this.positionNode=i,this.normalNode=r}setup(){const{textureXNode:e,textureYNode:t,textureZNode:s,scaleNode:o,positionNode:i,normalNode:r}=this;let a=r.abs().normalize();a=a.div(a.dot(f(1)));const c=i.yz.mul(o),u=i.zx.mul(o),l=i.xy.mul(o),h=e.value,d=t!==null?t.value:h,x=s!==null?s.value:h,v=oe(h,c).mul(a.x),C=oe(d,u).mul(a.y),E=oe(x,l).mul(a.z);return ye(v,C,E)}}const cd=g(gr),ud=(...n)=>cd(...n);m("triplanarTexture",ud);T("TriplanarTexturesNode",gr);new ha;new me;new me;new me;new kt;new me(0,0,-1);new Ze;new me;new me;new Ze;new ue;new Ye;S(Ut.x.oneMinus(),Ut.y);class ld extends wn{constructor(e=0){super(null,"vec4"),this.isVertexColorNode=!0,this.index=e}getAttributeName(){const e=this.index;return"color"+(e>0?e:"")}generate(e){const t=this.getAttributeName(e),s=e.hasGeometryAttribute(t);let o;return s===!0?o=super.generate(e):o=e.generateConst(this.nodeType,new Ze(1,1,1,1)),o}serialize(e){super.serialize(e),e.index=this.index}deserialize(e){super.deserialize(e),this.index=e.index}}T("VertexColorNode",ld);class fr extends Rt{constructor(e,t,s=null){super(e,t,s),this.renderer=s}updateReference(e){return this.reference=this.renderer!==null?this.renderer:e.renderer,this.reference}}const dd=(n,e,t)=>M(new fr(n,e,t));T("RendererReferenceNode",fr);const Is=1/6,Nr=n=>B(Is,B(n,B(n,n.negate().add(3)).sub(3)).add(1)),fn=n=>B(Is,B(n,B(n,B(3,n).sub(6))).add(4)),yr=n=>B(Is,B(n,B(n,B(-3,n).add(3)).add(3)).add(1)),Nn=n=>B(Is,$e(n,3)),fo=n=>Nr(n).add(fn(n)),No=n=>yr(n).add(Nn(n)),yo=n=>ye(-1,fn(n).div(Nr(n).add(fn(n)))),To=n=>ye(1,Nn(n).div(yr(n).add(Nn(n)))),xo=(n,e,t)=>{const s=n.uvNode,o=B(s,e.zw).add(.5),i=Ms(o),r=As(o),a=fo(r.x),c=No(r.x),u=yo(r.x),l=To(r.x),h=yo(r.y),d=To(r.y),x=S(i.x.add(u),i.y.add(h)).sub(.5).mul(e.xy),v=S(i.x.add(l),i.y.add(h)).sub(.5).mul(e.xy),C=S(i.x.add(u),i.y.add(d)).sub(.5).mul(e.xy),E=S(i.x.add(l),i.y.add(d)).sub(.5).mul(e.xy),L=fo(r.y).mul(ye(a.mul(n.uv(x).level(t)),c.mul(n.uv(v).level(t)))),b=No(r.y).mul(ye(a.mul(n.uv(C).level(t)),c.mul(n.uv(E).level(t))));return L.add(b)},hd=(n,e)=>{const t=S(n.size(ee(e))),s=S(n.size(ee(e.add(1)))),o=qe(1,t),i=qe(1,s),r=xo(n,w(o,t),Ms(e)),a=xo(n,w(i,s),pi(e));return As(e).mix(r,a)};class Tr extends P{constructor(e,t=y(3)){super("vec4"),this.textureNode=e,this.blurNode=t}setup(){return hd(this.textureNode,this.blurNode)}}const pd=g(Tr);m("bicubic",pd);T("TextureBicubicNode",Tr);class xr extends V{constructor(){super("vec2"),this.isPointUVNode=!0}generate(){return"vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )"}}R(xr);T("PointUVNode",xr);class Ie extends V{constructor(e=Ie.BACKGROUND_BLURRINESS,t=null){super(),this.scope=e,this.scene=t}setup(e){const t=this.scope,s=this.scene!==null?this.scene:e.scene;let o;return t===Ie.BACKGROUND_BLURRINESS?o=Ce("backgroundBlurriness","float",s):t===Ie.BACKGROUND_INTENSITY?o=Ce("backgroundIntensity","float",s):console.error("THREE.SceneNode: Unknown scope:",t),o}}Ie.BACKGROUND_BLURRINESS="backgroundBlurriness";Ie.BACKGROUND_INTENSITY="backgroundIntensity";R(Ie,Ie.BACKGROUND_BLURRINESS);R(Ie,Ie.BACKGROUND_INTENSITY);T("SceneNode",Ie);const vo={Uniform:"uniform",Storage:"storage",ReadOnlyStorage:"read-only-storage"},Hs={WriteOnly:"write-only",ReadOnly:"read-only",ReadWrite:"read-write"};class md extends ws{constructor(e,t,s=0){super(e,t,s),this.isStorageBufferNode=!0,this.access=vo.Storage,this.bufferObject=!1,this.bufferCount=s,this._attribute=null,this._varying=null,this.global=!0,e.isStorageBufferAttribute!==!0&&e.isStorageInstancedBufferAttribute!==!0&&(e.isInstancedBufferAttribute?e.isStorageInstancedBufferAttribute=!0:e.isStorageBufferAttribute=!0)}getHash(e){if(this.bufferCount===0){let t=e.globalCache.getData(this.value);return t===void 0&&(t={node:this},e.globalCache.setData(this.value,t)),t.node.uuid}return this.uuid}getInputType(){return"storageBuffer"}element(e){return mr(this,e)}setBufferObject(e){return this.bufferObject=e,this}setAccess(e){return this.access=e,this}toReadOnly(){return this.setAccess(vo.ReadOnlyStorage)}generate(e){if(e.isAvailable("storageBuffer"))return super.generate(e);const t=this.getNodeType(e);this._attribute===null&&(this._attribute=Es(this.value),this._varying=J(this._attribute));const s=this._varying.build(e,t);return e.registerTransform(s,this._attribute),s}}T("StorageBufferNode",md);class vr extends at{constructor(e,t,s=null){super(e,t),this.storeNode=s,this.isStorageTextureNode=!0,this.access=Hs.WriteOnly}getInputType(){return"storageTexture"}setup(e){super.setup(e);const t=e.getNodeProperties(this);t.storeNode=this.storeNode}setAccess(e){return this.access=e,this}generate(e,t){let s;return this.storeNode!==null?s=this.generateStore(e):s=super.generate(e,t),s}toReadOnly(){return this.setAccess(Hs.ReadOnly)}toWriteOnly(){return this.setAccess(Hs.WriteOnly)}generateStore(e){const t=e.getNodeProperties(this),{uvNode:s,storeNode:o}=t,i=super.generate(e,"property"),r=s.build(e,"uvec2"),a=o.build(e,"vec4"),c=e.generateTextureStore(e,i,r,a);e.addLineFlowCode(c)}}g(vr);T("StorageTextureNode",vr);const gd=A(({texture:n,uv:e})=>{const s=f().temp();return K(e.x.lessThan(1e-4),()=>{s.assign(f(1,0,0))}).elseif(e.y.lessThan(1e-4),()=>{s.assign(f(0,1,0))}).elseif(e.z.lessThan(1e-4),()=>{s.assign(f(0,0,1))}).elseif(e.x.greaterThan(1-1e-4),()=>{s.assign(f(-1,0,0))}).elseif(e.y.greaterThan(1-1e-4),()=>{s.assign(f(0,-1,0))}).elseif(e.z.greaterThan(1-1e-4),()=>{s.assign(f(0,0,-1))}).else(()=>{const i=n.uv(e.add(f(-.01,0,0))).r.sub(n.uv(e.add(f(.01,0,0))).r),r=n.uv(e.add(f(0,-.01,0))).r.sub(n.uv(e.add(f(0,.01,0))).r),a=n.uv(e.add(f(0,0,-.01))).r.sub(n.uv(e.add(f(0,0,.01))).r);s.assign(f(i,r,a))}),s.normalize()});class Sr extends at{constructor(e,t=null,s=null){super(e,t,s),this.isTexture3DNode=!0}getInputType(){return"texture3D"}getDefaultUV(){return f(.5,.5,.5)}setUpdateMatrix(){}setupUV(e,t){return t}generateUV(e,t){return t.build(e,"vec3")}normal(e){return gd({texture:this,uv:e})}}const fd=g(Sr);T("Texture3DNode",Sr);class Nd extends Rt{constructor(e,t,s=null){super(e,t,s),this.userData=s}update(e){this.reference=this.userData!==null?this.userData:e.object.userData,super.update(e)}}T("UserDataNode",Nd);const yd=A(({base:n,blend:e})=>{const t=s=>e[s].lessThan(ui).cond(e[s],n[s].oneMinus().div(e[s]).oneMinus().max(0));return f(t("x"),t("y"),t("z"))}).setLayout({name:"burnColor",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),Td=A(({base:n,blend:e})=>{const t=s=>e[s].equal(1).cond(e[s],n[s].div(e[s].oneMinus()).max(0));return f(t("x"),t("y"),t("z"))}).setLayout({name:"dodgeColor",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),xd=A(({base:n,blend:e})=>{const t=s=>n[s].oneMinus().mul(e[s].oneMinus()).oneMinus();return f(t("x"),t("y"),t("z"))}).setLayout({name:"screenColor",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),vd=A(({base:n,blend:e})=>{const t=s=>n[s].lessThan(.5).cond(n[s].mul(e[s],2),n[s].oneMinus().mul(e[s].oneMinus()).oneMinus());return f(t("x"),t("y"),t("z"))}).setLayout({name:"overlayColor",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]});class se extends P{constructor(e,t,s){super(),this.blendMode=e,this.baseNode=t,this.blendNode=s}setup(){const{blendMode:e,baseNode:t,blendNode:s}=this,o={base:t,blend:s};let i=null;return e===se.BURN?i=yd(o):e===se.DODGE?i=Td(o):e===se.SCREEN?i=xd(o):e===se.OVERLAY&&(i=vd(o)),i}}se.BURN="burn";se.DODGE="dodge";se.SCREEN="screen";se.OVERLAY="overlay";const Sd=g(se,se.BURN),Md=g(se,se.DODGE),Ad=g(se,se.OVERLAY),Rd=g(se,se.SCREEN);m("burn",Sd);m("dodge",Md);m("overlay",Ad);m("screen",Rd);T("BlendModeNode",se);const Cd=A(({textureNode:n,bumpScale:e})=>{const t=o=>n.cache().context({getUV:i=>o(i.uvNode||xe()),forceUVContext:!0}),s=y(t(o=>o));return S(y(t(o=>o.add(o.dFdx()))).sub(s),y(t(o=>o.add(o.dFdy()))).sub(s)).mul(e)}),wd=A(n=>{const{surf_pos:e,surf_norm:t,dHdxy:s}=n,o=e.dFdx().normalize(),i=e.dFdy().normalize(),r=t,a=i.cross(r),c=r.cross(o),u=o.dot(a).mul(gs),l=u.sign().mul(s.x.mul(a).add(s.y.mul(c)));return u.abs().mul(t).sub(l).normalize()});class Mr extends P{constructor(e,t=null){super("vec3"),this.textureNode=e,this.scaleNode=t}setup(){const e=this.scaleNode!==null?this.scaleNode:1,t=Cd({textureNode:this.textureNode,bumpScale:e});return wd({surf_pos:ce,surf_norm:Ke,dHdxy:t})}}const Ed=g(Mr);m("bumpMap",Ed);T("BumpMapNode",Mr);const Id=A(({color:n,adjustment:e})=>e.mix(we(n.rgb),n.rgb)),Ld=A(({color:n,adjustment:e})=>{const t=ye(n.r,n.g,n.b).div(3),s=n.r.max(n.g.max(n.b)),o=s.sub(t).mul(e).mul(-3);return Q(n.rgb,s,o)}),Vd=A(({color:n,adjustment:e})=>{const t=f(.57735,.57735,.57735),s=e.cos();return f(n.rgb.mul(s).add(t.cross(n.rgb).mul(e.sin()).add(t.mul(Rs(t,n.rgb).mul(s.oneMinus())))))});class Ne extends P{constructor(e,t,s=y(1)){super("vec3"),this.method=e,this.colorNode=t,this.adjustmentNode=s}setup(){const{method:e,colorNode:t,adjustmentNode:s}=this,o={color:t,adjustment:s};let i=null;return e===Ne.SATURATION?i=Id(o):e===Ne.VIBRANCE?i=Ld(o):e===Ne.HUE?i=Vd(o):console.error(`${this.type}: Method "${this.method}" not supported!`),i}}Ne.SATURATION="saturation";Ne.VIBRANCE="vibrance";Ne.HUE="hue";const Od=g(Ne,Ne.SATURATION),_d=g(Ne,Ne.VIBRANCE),bd=g(Ne,Ne.HUE),Dd=f(.2125,.7154,.0721),we=(n,e=Dd)=>Rs(n,e),Ar=(n,e)=>Q(f(0),n,we(n).sub(e).max(0));m("saturation",Od);m("vibrance",_d);m("hue",bd);m("threshold",Ar);T("ColorAdjustmentNode",Ne);const zd=A(n=>{const{eye_pos:e,surf_norm:t,mapN:s,uv:o}=n,i=e.dFdx(),r=e.dFdy(),a=o.dFdx(),c=o.dFdy(),u=t,l=r.cross(u),h=u.cross(i),d=l.mul(a.x).add(h.mul(c.x)),x=l.mul(a.y).add(h.mul(c.y)),v=d.dot(d).max(x.dot(x)),C=gs.mul(v.inverseSqrt());return ye(d.mul(s.x,C),x.mul(s.y,C),u.mul(s.z)).normalize()});class Rr extends P{constructor(e,t=null){super("vec3"),this.node=e,this.scaleNode=t,this.normalMapType=qn}setup(e){const{normalMapType:t,scaleNode:s}=this;let o=this.node.mul(2).sub(1);s!==null&&(o=f(o.xy.mul(s),o.z));let i=null;return t===pa?i=Ai.mul(o).normalize():t===qn&&(e.hasGeometryAttribute("tangent")===!0?i=gt.mul(o).normalize():i=zd({eye_pos:ce,surf_norm:Ke,mapN:o,uv:xe()})),i}}const Fd=g(Rr);m("normalMap",Fd);T("NormalMapNode",Rr);class Cr extends P{constructor(e,t){super(),this.sourceNode=e,this.stepsNode=t}setup(){const{sourceNode:e,stepsNode:t}=this;return e.mul(t).floor().div(t)}}const Pd=g(Cr);m("posterize",Pd);T("PosterizeNode",Cr);const Ud=A(({color:n,exposure:e})=>n.mul(e).clamp()),Bd=A(({color:n,exposure:e})=>(n=n.mul(e),n.div(n.add(1)).clamp())),kd=A(({color:n,exposure:e})=>{n=n.mul(e),n=n.sub(.004).max(0);const t=n.mul(n.mul(6.2).add(.5)),s=n.mul(n.mul(6.2).add(1.7)).add(.06);return t.div(s).pow(2.2)}),Gd=A(({color:n})=>{const e=n.mul(n.add(.0245786)).sub(90537e-9),t=n.mul(n.add(.432951).mul(.983729)).add(.238081);return e.div(t)}),Hd=A(({color:n,exposure:e})=>{const t=le(.59719,.35458,.04823,.076,.90834,.01566,.0284,.13383,.83777),s=le(1.60475,-.53108,-.07367,-.10208,1.10813,-.00605,-.00327,-.07276,1.07602);return n=n.mul(e).div(.6),n=t.mul(n),n=Gd({color:n}),n=s.mul(n),n.clamp()}),$d=le(f(1.6605,-.1246,-.0182),f(-.5876,1.1329,-.1006),f(-.0728,-.0083,1.1187)),Wd=le(f(.6274,.0691,.0164),f(.3293,.9195,.088),f(.0433,.0113,.8956)),qd=A(([n])=>{const e=f(n).toVar(),t=f(e.mul(e)).toVar(),s=f(t.mul(t)).toVar();return y(15.5).mul(s.mul(t)).sub(B(40.14,s.mul(e))).add(B(31.96,s).sub(B(6.868,t.mul(e))).add(B(.4298,t).add(B(.1191,e).sub(.00232))))}),Xd=A(({color:n,exposure:e})=>{const t=f(n).toVar(),s=le(f(.856627153315983,.137318972929847,.11189821299995),f(.0951212405381588,.761241990602591,.0767994186031903),f(.0482516061458583,.101439036467562,.811302368396859)),o=le(f(1.1271005818144368,-.1413297634984383,-.14132976349843826),f(-.11060664309660323,1.157823702216272,-.11060664309660294),f(-.016493938717834573,-.016493938717834257,1.2519364065950405)),i=y(-12.47393),r=y(4.026069);return t.mulAssign(e),t.assign(Wd.mul(t)),t.assign(s.mul(t)),t.assign(pe(t,1e-10)),t.assign(Ss(t)),t.assign(t.sub(i).div(r.sub(i))),t.assign(nt(t,0,1)),t.assign(qd(t)),t.assign(o.mul(t)),t.assign($e(pe(f(0),t),f(2.2))),t.assign($d.mul(t)),t.assign(nt(t,0,1)),t}),jd=A(({color:n,exposure:e})=>{const t=y(.76),s=y(.15);n=n.mul(e);const o=He(n.r,He(n.g,n.b)),i=Re(o.lessThan(.08),o.sub(B(6.25,o.mul(o))),.04);n.subAssign(i);const r=pe(n.r,pe(n.g,n.b));K(r.lessThan(t),()=>n);const a=ze(1,t),c=ze(1,a.mul(a).div(r.add(a.sub(t))));n.mulAssign(c.div(r));const u=ze(1,qe(1,s.mul(r.sub(c)).add(1)));return Q(n,f(c),u)}).setLayout({name:"NeutralToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),Zd={[ma]:Ud,[ga]:Bd,[fa]:kd,[Na]:Hd,[ya]:Xd,[Ta]:jd};class wr extends P{constructor(e=Dt,t=Kd,s=null){super("vec3"),this.toneMapping=e,this.exposureNode=t,this.colorNode=s}getCacheKey(){let e=super.getCacheKey();return e="{toneMapping:"+this.toneMapping+",nodes:"+e+"}",e}setup(e){const t=this.colorNode||e.context.color,s=this.toneMapping;if(s===Dt)return t;const o={exposure:this.exposureNode,color:t},i=Zd[s];let r=null;return i?r=i(o):(console.error("ToneMappingNode: Unsupported Tone Mapping configuration.",s),r=t),r}}const Yd=(n,e,t)=>M(new wr(n,M(e),M(t))),Kd=dd("toneMappingExposure","float");m("toneMapping",(n,e,t)=>Yd(e,t,n));T("ToneMappingNode",wr);let $s=null;class Er extends Ht{constructor(e=Ut,t=null){$s===null&&($s=new Po),super(e,t,$s)}updateReference(){return this}}const Jd=g(Er);m("viewportSharedTexture",Jd);T("ViewportSharedTextureNode",Er);const Qd=new ue;class yn extends at{constructor(e,t){super(t),this.passNode=e,this.setUpdateMatrix(!1)}setup(e){return this.passNode.build(e),super.setup(e)}clone(){return new this.constructor(this.passNode,this.value)}}class $t extends P{constructor(e,t,s){super("vec4"),this.scope=e,this.scene=t,this.camera=s,this._pixelRatio=1,this._width=1,this._height=1;const o=new vn;o.isRenderTargetTexture=!0,o.name="PostProcessingDepth";const i=new Ye(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:xa});i.texture.name="PostProcessing",i.depthTexture=o,this.renderTarget=i,this.updateBeforeType=z.FRAME,this._textureNode=M(new yn(this,i.texture)),this._depthTextureNode=M(new yn(this,o)),this._linearDepthNode=null,this._viewZNode=null,this._cameraNear=O(0),this._cameraFar=O(0),this.isPassNode=!0}isGlobal(){return!0}getTextureNode(){return this._textureNode}getTextureDepthNode(){return this._depthTextureNode}getViewZNode(){if(this._viewZNode===null){const e=this._cameraNear,t=this._cameraFar;this._viewZNode=Yi(this._depthTextureNode,e,t)}return this._viewZNode}getLinearDepthNode(){if(this._linearDepthNode===null){const e=this._cameraNear,t=this._cameraFar;this._linearDepthNode=ns(this.getViewZNode(),e,t)}return this._linearDepthNode}setup(){return this.scope===$t.COLOR?this.getTextureNode():this.getLinearDepthNode()}updateBefore(e){const{renderer:t}=e,{scene:s,camera:o}=this;this._pixelRatio=t.getPixelRatio();const i=t.getSize(Qd);this.setSize(i.width,i.height);const r=t.toneMapping,a=t.toneMappingNode,c=t.getRenderTarget();this._cameraNear.value=o.near,this._cameraFar.value=o.far,t.toneMapping=Dt,t.toneMappingNode=null,t.setRenderTarget(this.renderTarget),t.render(s,o),t.toneMapping=r,t.toneMappingNode=a,t.setRenderTarget(c)}setSize(e,t){this._width=e,this._height=t;const s=this._width*this._pixelRatio,o=this._height*this._pixelRatio;this.renderTarget.setSize(s,o)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}dispose(){this.renderTarget.dispose()}}$t.COLOR="color";$t.DEPTH="depth";const Ls=(n,e)=>M(new yn(n,e));T("PassNode",$t);const Ws=new va(-1,1,1,-1,0,1);class eh extends Ma{constructor(e=!1){super();const t=e===!1?[0,-1,0,1,2,1]:[0,2,0,0,2,0];this.setAttribute("position",new Xn([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new Xn(t,2))}}const th=new eh;class Wt extends Sa{constructor(e=null){super(th,e),this.camera=Ws}renderAsync(e){return e.renderAsync(this,Ws)}render(e){e.render(this,Ws)}}const So=new Wt,Mo=new Wt;class sh extends P{constructor(e,t=2){super("vec4"),this.textureNode=e,this.sigma=t,this.directionNode=S(1),this._invSize=O(new ue),this._passDirection=O(new ue),this._horizontalRT=new Ye,this._horizontalRT.texture.name="GaussianBlurNode.horizontal",this._verticalRT=new Ye,this._verticalRT.texture.name="GaussianBlurNode.vertical",this._textureNode=Ls(this,this._verticalRT.texture),this.updateBeforeType=z.RENDER,this.resolution=new ue(1,1)}setSize(e,t){e=Math.max(Math.round(e*this.resolution.x),1),t=Math.max(Math.round(t*this.resolution.y),1),this._invSize.value.set(1/e,1/t),this._horizontalRT.setSize(e,t),this._verticalRT.setSize(e,t)}updateBefore(e){const{renderer:t}=e,s=this.textureNode,o=s.value,i=t.getRenderTarget(),r=s.value;So.material=this._material,Mo.material=this._material,this.setSize(o.image.width,o.image.height);const a=o.type;this._horizontalRT.texture.type=a,this._verticalRT.texture.type=a,t.setRenderTarget(this._horizontalRT),this._passDirection.value.set(1,0),So.render(t),s.value=this._horizontalRT.texture,t.setRenderTarget(this._verticalRT),this._passDirection.value.set(0,1),Mo.render(t),t.setRenderTarget(i),s.value=r}getTextureNode(){return this._textureNode}setup(e){const t=this.textureNode;if(t.isTextureNode!==!0)return console.error("GaussianBlurNode requires a TextureNode."),w();const s=t.uvNode||xe(),o=c=>t.cache().context({getUV:()=>c,forceUVContext:!0}),i=A(()=>{const c=3+2*this.sigma,u=this._getCoefficients(c),l=this._invSize,h=S(this.directionNode).mul(this._passDirection),d=y(u[0]).toVar(),x=w(o(s).mul(d)).toVar();for(let v=1;v<c;v++){const C=y(v),E=y(u[v]),L=S(h.mul(l.mul(C))).toVar(),b=w(o(s.add(L))),I=w(o(s.sub(L)));x.addAssign(b.add(I).mul(E)),d.addAssign(B(2,E))}return x.div(d)}),r=this._material||(this._material=e.createNodeMaterial());r.fragmentNode=i();const a=e.getNodeProperties(this);return a.textureNode=t,this._textureNode}_getCoefficients(e){const t=[];for(let s=0;s<e;s++)t.push(.39894*Math.exp(-.5*s*s/(e*e))/e);return t}}const nh=(n,e)=>M(new sh(M(n),e));m("gaussianBlur",nh);const qs=new ue,Ao=new Wt;class oh extends P{constructor(e,t=.96){super(e),this.textureNode=e,this.textureNodeOld=oe(),this.damp=O(t),this._compRT=new Ye,this._compRT.texture.name="AfterImageNode.comp",this._oldRT=new Ye,this._oldRT.texture.name="AfterImageNode.old",this._textureNode=Ls(this,this._compRT.texture),this.updateBeforeType=z.RENDER}getTextureNode(){return this._textureNode}setSize(e,t){this._compRT.setSize(e,t),this._oldRT.setSize(e,t)}updateBefore(e){const{renderer:t}=e,s=this.textureNode,i=s.value.type;this._compRT.texture.type=i,this._oldRT.texture.type=i,t.getDrawingBufferSize(qs),this.setSize(qs.x,qs.y);const r=t.toneMapping,a=t.toneMappingNode,c=t.getRenderTarget(),u=s.value;this.textureNodeOld.value=this._oldRT.texture,t.toneMapping=Dt,t.toneMappingNode=null,t.setRenderTarget(this._compRT),Ao.render(t);const l=this._oldRT;this._oldRT=this._compRT,this._compRT=l,t.toneMapping=r,t.toneMappingNode=a,t.setRenderTarget(c),s.value=u}setup(e){const t=this.textureNode,s=this.textureNodeOld;if(t.isTextureNode!==!0)return console.error("AfterImageNode requires a TextureNode."),w();const o=t.uvNode||xe();s.uvNode=o;const i=l=>t.cache().context({getUV:()=>l,forceUVContext:!0}),r=A(([l,h])=>{const d=y(h).toVar(),x=w(l).toVar();return pe(Dn(x.sub(d)),0)}),a=A(()=>{const l=w(s),h=w(i(o));return l.mulAssign(this.damp.mul(r(l,.1))),pe(h,l)}),c=this._materialComposed||(this._materialComposed=e.createNodeMaterial());c.fragmentNode=a(),Ao.material=c;const u=e.getNodeProperties(this);return u.textureNode=t,this._textureNode}}const ih=(n,e)=>M(new oh(M(n),e));m("afterImage",ih);const Ro=new Wt;class rh extends P{constructor(e,t,s,o){super("vec4"),this.textureNode=e,this.tresholdNode=t,this.scaleNode=s,this.colorNode=f(.1,0,1),this.samples=o,this.resolution=new ue(1,1),this._renderTarget=new Ye,this._renderTarget.texture.name="anamorphic",this._invSize=O(new ue),this._textureNode=Ls(this,this._renderTarget.texture),this.updateBeforeType=z.RENDER}getTextureNode(){return this._textureNode}setSize(e,t){this._invSize.value.set(1/e,1/t),e=Math.max(Math.round(e*this.resolution.x),1),t=Math.max(Math.round(t*this.resolution.y),1),this._renderTarget.setSize(e,t)}updateBefore(e){const{renderer:t}=e,s=this.textureNode,o=s.value;this._renderTarget.texture.type=o.type;const i=t.getRenderTarget(),r=s.value;Ro.material=this._material,this.setSize(o.image.width,o.image.height),t.setRenderTarget(this._renderTarget),Ro.render(t),t.setRenderTarget(i),s.value=r}setup(e){const t=this.textureNode;if(t.isTextureNode!==!0)return console.error("AnamorphNode requires a TextureNode."),w();const s=t.uvNode||xe(),o=c=>t.cache().context({getUV:()=>c,forceUVContext:!0}),i=A(()=>{const c=this.samples,u=Math.floor(c/2),l=f(0).toVar();return Ee({start:-u,end:u},({i:h})=>{const d=y(h).abs().div(u).oneMinus(),x=S(s.x.add(this._invSize.x.mul(h).mul(this.scaleNode)),s.y),v=o(x),C=Ar(v,this.tresholdNode).mul(d);l.addAssign(C)}),l.mul(this.colorNode)}),r=this._material||(this._material=e.createNodeMaterial());r.fragmentNode=i();const a=e.getNodeProperties(this);return a.textureNode=t,this._textureNode}}const ah=(n,e=.9,t=3,s=32)=>M(new rh(M(n),M(e),M(t),s));m("anamorphic",ah);class ch extends P{constructor(e){super(),this.textureNode=e,this.updateBeforeType=z.RENDER,this._invSize=O(new ue)}updateBefore(){const e=this.textureNode.value;this._invSize.value.set(1/e.image.width,1/e.image.height)}setup(){const{textureNode:e}=this,t=e.uvNode||xe(),s=r=>this.textureNode.cache().context({getUV:()=>r,forceUVContext:!0});return A(()=>{const r=this._invSize,a=le(-1,-2,-1,0,0,0,1,2,1),c=le(-1,0,1,-2,0,2,-1,0,1),u=we(s(t.add(r.mul(S(-1,-1)))).xyz),l=we(s(t.add(r.mul(S(-1,0)))).xyz),h=we(s(t.add(r.mul(S(-1,1)))).xyz),d=we(s(t.add(r.mul(S(0,-1)))).xyz),x=we(s(t.add(r.mul(S(0,0)))).xyz),v=we(s(t.add(r.mul(S(0,1)))).xyz),C=we(s(t.add(r.mul(S(1,-1)))).xyz),E=we(s(t.add(r.mul(S(1,0)))).xyz),L=we(s(t.add(r.mul(S(1,1)))).xyz),b=ye(a[0][0].mul(u),a[1][0].mul(d),a[2][0].mul(C),a[0][1].mul(l),a[1][1].mul(x),a[2][1].mul(E),a[0][2].mul(h),a[1][2].mul(v),a[2][2].mul(L)),I=ye(c[0][0].mul(u),c[1][0].mul(d),c[2][0].mul(C),c[0][1].mul(l),c[1][1].mul(x),c[2][1].mul(E),c[0][2].mul(h),c[1][2].mul(v),c[2][2].mul(L)),Y=b.mul(b).add(I.mul(I)).sqrt();return w(f(Y),1)})()}}const uh=n=>M(new ch(M(n)));m("sobel",uh);class lh extends P{constructor(e,t,s=1,o=.025,i=1){super(),this.textureNode=e,this.viewZNode=t,this.focus=O(s),this.aperture=O(o),this.maxblur=O(i),this._aspect=O(0),this.updateBeforeType=z.RENDER}updateBefore(){const e=this.textureNode.value;this._aspect.value=e.image.width/e.image.height}setup(){const{textureNode:e}=this,t=e.uvNode||xe(),s=r=>this.textureNode.uv(r);return A(()=>{const r=S(1,this._aspect),a=this.focus.add(this.viewZNode),c=S(nt(a.mul(this.aperture),this.maxblur.negate(),this.maxblur)),u=c.mul(.9),l=c.mul(.7),h=c.mul(.4);let d=w(0);return d=d.add(s(t)),d=d.add(s(t.add(S(0,.4).mul(r).mul(c)))),d=d.add(s(t.add(S(.15,.37).mul(r).mul(c)))),d=d.add(s(t.add(S(.29,.29).mul(r).mul(c)))),d=d.add(s(t.add(S(-.37,.15).mul(r).mul(c)))),d=d.add(s(t.add(S(.4,0).mul(r).mul(c)))),d=d.add(s(t.add(S(.37,-.15).mul(r).mul(c)))),d=d.add(s(t.add(S(.29,-.29).mul(r).mul(c)))),d=d.add(s(t.add(S(-.15,-.37).mul(r).mul(c)))),d=d.add(s(t.add(S(0,-.4).mul(r).mul(c)))),d=d.add(s(t.add(S(-.15,.37).mul(r).mul(c)))),d=d.add(s(t.add(S(-.29,.29).mul(r).mul(c)))),d=d.add(s(t.add(S(.37,.15).mul(r).mul(c)))),d=d.add(s(t.add(S(-.4,0).mul(r).mul(c)))),d=d.add(s(t.add(S(-.37,-.15).mul(r).mul(c)))),d=d.add(s(t.add(S(-.29,-.29).mul(r).mul(c)))),d=d.add(s(t.add(S(.15,-.37).mul(r).mul(c)))),d=d.add(s(t.add(S(.15,.37).mul(r).mul(u)))),d=d.add(s(t.add(S(-.37,.15).mul(r).mul(u)))),d=d.add(s(t.add(S(.37,-.15).mul(r).mul(u)))),d=d.add(s(t.add(S(-.15,-.37).mul(r).mul(u)))),d=d.add(s(t.add(S(-.15,.37).mul(r).mul(u)))),d=d.add(s(t.add(S(.37,.15).mul(r).mul(u)))),d=d.add(s(t.add(S(-.37,-.15).mul(r).mul(u)))),d=d.add(s(t.add(S(.15,-.37).mul(r).mul(u)))),d=d.add(s(t.add(S(.29,.29).mul(r).mul(l)))),d=d.add(s(t.add(S(.4,0).mul(r).mul(l)))),d=d.add(s(t.add(S(.29,-.29).mul(r).mul(l)))),d=d.add(s(t.add(S(0,-.4).mul(r).mul(l)))),d=d.add(s(t.add(S(-.29,.29).mul(r).mul(l)))),d=d.add(s(t.add(S(-.4,0).mul(r).mul(l)))),d=d.add(s(t.add(S(-.29,-.29).mul(r).mul(l)))),d=d.add(s(t.add(S(0,.4).mul(r).mul(l)))),d=d.add(s(t.add(S(.29,.29).mul(r).mul(h)))),d=d.add(s(t.add(S(.4,0).mul(r).mul(h)))),d=d.add(s(t.add(S(.29,-.29).mul(r).mul(h)))),d=d.add(s(t.add(S(0,-.4).mul(r).mul(h)))),d=d.add(s(t.add(S(-.29,.29).mul(r).mul(h)))),d=d.add(s(t.add(S(-.4,0).mul(r).mul(h)))),d=d.add(s(t.add(S(-.29,-.29).mul(r).mul(h)))),d=d.add(s(t.add(S(0,.4).mul(r).mul(h)))),d=d.div(41),d.a=1,w(d)})()}}const dh=(n,e,t,s,o)=>M(new lh(M(n),M(e),t,s,o));m("dof",dh);const Co=new Wt;class hh extends P{constructor(e,t=new ue(.5,.5),s=1.57,o=1){super("vec4"),this.colorNode=e,this.center=O(t),this.angle=O(s),this.scale=O(o),this._renderTarget=new Ye,this._renderTarget.texture.name="dotScreen",this._size=O(new ue),this._textureNode=Ls(this,this._renderTarget.texture),this.updateBeforeType=z.RENDER}getTextureNode(){return this._textureNode}setSize(e,t){this._size.value.set(e,t),this._renderTarget.setSize(e,t)}updateBefore(e){const{renderer:t}=e,s=this.colorNode,o=s.value;this._renderTarget.texture.type=o.type;const i=t.getRenderTarget(),r=s.value;Co.material=this._material,this.setSize(o.image.width,o.image.height),t.setRenderTarget(this._renderTarget),Co.render(t),t.setRenderTarget(i),s.value=r}setup(e){const t=this.colorNode,s=A(()=>{const a=Me(this.angle),c=Oe(this.angle),u=xe().mul(this._size).sub(this.center),l=S(c.mul(u.x).sub(a.mul(u.y)),a.mul(u.x).add(c.mul(u.y))).mul(this.scale);return Me(l.x).mul(Me(l.y)).mul(4)}),o=A(()=>{const a=t,c=ye(a.r,a.g,a.b).div(3);return w(f(c.mul(10).sub(5).add(s())),a.a)}),i=this._material||(this._material=e.createNodeMaterial());i.fragmentNode=o();const r=e.getNodeProperties(this);return r.textureNode=t,this._textureNode}}const ph=(n,e,t,s)=>M(new hh(M(n),e,t,s));m("dotScreen",ph);class mh extends P{constructor(e,t=.005,s=0){super("vec4"),this.textureNode=e,this.amount=O(t),this.angle=O(s),this.updateBeforeType=z.RENDER}updateBefore(){}setup(){const{textureNode:e}=this,t=e.uvNode||xe(),s=i=>this.textureNode.uv(i);return A(()=>{const i=S(Oe(this.angle),Me(this.angle)).mul(this.amount),r=s(t.add(i)),a=s(t),c=s(t.sub(i));return w(r.r,a.g,c.b,a.a)})()}}const gh=(n,e,t)=>M(new mh(M(n),e,t));m("rgbShift",gh);class Ir extends P{constructor(e=null,t={}){super(),this.functionNode=e,this.parameters=t}setParameters(e){return this.parameters=e,this}getParameters(){return this.parameters}getNodeType(e){return this.functionNode.getNodeType(e)}generate(e){const t=[],s=this.functionNode,o=s.getInputs(e),i=this.parameters;if(Array.isArray(i))for(let a=0;a<i.length;a++){const c=o[a],u=i[a];t.push(u.build(e,c.type))}else for(const a of o){const c=i[a.name];if(c!==void 0)t.push(c.build(e,a.type));else throw new Error(`FunctionCallNode: Input '${a.name}' not found in FunctionNode.`)}return`${s.build(e,"property")}( ${t.join(", ")} )`}}const fh=(n,...e)=>(e=e.length>1||e[0]&&e[0].isNode===!0?ft(e):xs(e[0]),M(new Ir(M(n),e)));m("call",fh);T("FunctionCallNode",Ir);class Lr extends V{constructor(e=null){super(),this._value=e,this._cache=null,this.inputType=null,this.outpuType=null,this.events=new _o,this.isScriptableValueNode=!0}get isScriptableOutputNode(){return this.outputType!==null}set value(e){this._value!==e&&(this._cache&&this.inputType==="URL"&&this.value.value instanceof ArrayBuffer&&(URL.revokeObjectURL(this._cache),this._cache=null),this._value=e,this.events.dispatchEvent({type:"change"}),this.refresh())}get value(){return this._value}refresh(){this.events.dispatchEvent({type:"refresh"})}getValue(){const e=this.value;if(e&&this._cache===null&&this.inputType==="URL"&&e.value instanceof ArrayBuffer)this._cache=URL.createObjectURL(new Blob([e.value]));else if(e&&e.value!==null&&e.value!==void 0&&((this.inputType==="URL"||this.inputType==="String")&&typeof e.value=="string"||this.inputType==="Number"&&typeof e.value=="number"||this.inputType==="Vector2"&&e.value.isVector2||this.inputType==="Vector3"&&e.value.isVector3||this.inputType==="Vector4"&&e.value.isVector4||this.inputType==="Color"&&e.value.isColor||this.inputType==="Matrix3"&&e.value.isMatrix3||this.inputType==="Matrix4"&&e.value.isMatrix4))return e.value;return this._cache||e}getNodeType(e){return this.value&&this.value.isNode?this.value.getNodeType(e):"float"}setup(){return this.value&&this.value.isNode?this.value:y()}serialize(e){super.serialize(e),this.value!==null?this.inputType==="ArrayBuffer"?e.value=$o(this.value):e.value=this.value?this.value.toJSON(e.meta).uuid:null:e.value=null,e.inputType=this.inputType,e.outputType=this.outputType}deserialize(e){super.deserialize(e);let t=null;e.value!==null&&(e.inputType==="ArrayBuffer"?t=Wo(e.value):e.inputType==="Texture"?t=e.meta.textures[e.value]:t=e.meta.nodes[e.value]||null),this.value=t,this.inputType=e.inputType,this.outputType=e.outputType}}const os=g(Lr);m("scriptableValue",os);T("ScriptableValueNode",Lr);class Vr extends Map{get(e,t=null,...s){if(this.has(e))return super.get(e);if(t!==null){const o=t(...s);return this.set(e,o),o}}}class Nh{constructor(e){this.scriptableNode=e}get parameters(){return this.scriptableNode.parameters}get layout(){return this.scriptableNode.getLayout()}getInputLayout(e){return this.scriptableNode.getInputLayout(e)}get(e){const t=this.parameters[e];return t?t.getValue():null}}const Xs=new Vr;class Or extends V{constructor(e=null,t={}){super(),this.codeNode=e,this.parameters=t,this._local=new Vr,this._output=os(),this._outputs={},this._source=this.source,this._method=null,this._object=null,this._value=null,this._needsOutputUpdate=!0,this.onRefresh=this.onRefresh.bind(this),this.isScriptableNode=!0}get source(){return this.codeNode?this.codeNode.code:""}setLocal(e,t){return this._local.set(e,t)}getLocal(e){return this._local.get(e)}onRefresh(){this._refresh()}getInputLayout(e){for(const t of this.getLayout())if(t.inputType&&(t.id===e||t.name===e))return t}getOutputLayout(e){for(const t of this.getLayout())if(t.outputType&&(t.id===e||t.name===e))return t}setOutput(e,t){const s=this._outputs;return s[e]===void 0?s[e]=os(t):s[e].value=t,this}getOutput(e){return this._outputs[e]}getParameter(e){return this.parameters[e]}setParameter(e,t){const s=this.parameters;return t&&t.isScriptableNode?(this.deleteParameter(e),s[e]=t,s[e].getDefaultOutput().events.addEventListener("refresh",this.onRefresh)):t&&t.isScriptableValueNode?(this.deleteParameter(e),s[e]=t,s[e].events.addEventListener("refresh",this.onRefresh)):s[e]===void 0?(s[e]=os(t),s[e].events.addEventListener("refresh",this.onRefresh)):s[e].value=t,this}getValue(){return this.getDefaultOutput().getValue()}deleteParameter(e){let t=this.parameters[e];return t&&(t.isScriptableNode&&(t=t.getDefaultOutput()),t.events.removeEventListener("refresh",this.onRefresh)),this}clearParameters(){for(const e of Object.keys(this.parameters))this.deleteParameter(e);return this.needsUpdate=!0,this}call(e,...t){const o=this.getObject()[e];if(typeof o=="function")return o(...t)}async callAsync(e,...t){const o=this.getObject()[e];if(typeof o=="function")return o.constructor.name==="AsyncFunction"?await o(...t):o(...t)}getNodeType(e){return this.getDefaultOutputNode().getNodeType(e)}refresh(e=null){e!==null?this.getOutput(e).refresh():this._refresh()}getObject(){if(this.needsUpdate&&this.dispose(),this._object!==null)return this._object;const e=()=>this.refresh(),t=(u,l)=>this.setOutput(u,l),s=new Nh(this),o=Xs.get("THREE"),i=Xs.get("TSL"),r=this.getMethod(this.codeNode),a=[s,this._local,Xs,e,t,o,i];this._object=r(...a);const c=this._object.layout;if(c&&(c.cache===!1&&this._local.clear(),this._output.outputType=c.outputType||null,Array.isArray(c.elements)))for(const u of c.elements){const l=u.id||u.name;u.inputType&&(this.getParameter(l)===void 0&&this.setParameter(l,null),this.getParameter(l).inputType=u.inputType),u.outputType&&(this.getOutput(l)===void 0&&this.setOutput(l,null),this.getOutput(l).outputType=u.outputType)}return this._object}deserialize(e){super.deserialize(e);for(const t in this.parameters){let s=this.parameters[t];s.isScriptableNode&&(s=s.getDefaultOutput()),s.events.addEventListener("refresh",this.onRefresh)}}getLayout(){return this.getObject().layout}getDefaultOutputNode(){const e=this.getDefaultOutput().value;return e&&e.isNode?e:y()}getDefaultOutput(){return this._exec()._output}getMethod(){if(this.needsUpdate&&this.dispose(),this._method!==null)return this._method;const e=["parameters","local","global","refresh","setOutput","THREE","TSL"],s=["layout","init","main","dispose"].join(", "),o="var "+s+`; var output = {};
`,i=`
return { ...output, `+s+" };",r=o+this.codeNode.code+i;return this._method=new Function(...e,r),this._method}dispose(){this._method!==null&&(this._object&&typeof this._object.dispose=="function"&&this._object.dispose(),this._method=null,this._object=null,this._source=null,this._value=null,this._needsOutputUpdate=!0,this._output.value=null,this._outputs={})}setup(){return this.getDefaultOutputNode()}set needsUpdate(e){e===!0&&this.dispose()}get needsUpdate(){return this.source!==this._source}_exec(){return this.codeNode===null?this:(this._needsOutputUpdate===!0&&(this._value=this.call("main"),this._needsOutputUpdate=!1),this._output.value=this._value,this)}_refresh(){this.needsUpdate=!0,this._exec(),this._output.refresh()}}const yh=g(Or);m("scriptable",yh);T("ScriptableNode",Or);class Vs extends V{constructor(e,t){super("float"),this.isFogNode=!0,this.colorNode=e,this.factorNode=t}getViewZNode(e){let t;const s=e.context.getViewZ;return s!==void 0&&(t=s(this)),(t||ce.z).negate()}setup(){return this.factorNode}}const Th=g(Vs);m("fog",Th);T("FogNode",Vs);class _r extends Vs{constructor(e,t,s){super(e),this.isFogRangeNode=!0,this.nearNode=t,this.farNode=s}setup(e){const t=this.getViewZNode(e);return Fe(this.nearNode,this.farNode,t)}}const xh=g(_r);m("rangeFog",xh);T("FogRangeNode",_r);class br extends Vs{constructor(e,t){super(e),this.isFogExp2Node=!0,this.densityNode=t}setup(e){const t=this.getViewZNode(e),s=this.densityNode;return s.mul(s,t,t).negate().exp().oneMinus()}}const vh=g(br);m("densityFog",vh);T("FogExp2Node",br);let et=null,tt=null;class Dr extends V{constructor(e=y(),t=y()){super(),this.minNode=e,this.maxNode=t}getVectorLength(e){const t=e.getTypeLength(je(this.minNode.value)),s=e.getTypeLength(je(this.maxNode.value));return t>s?t:s}getNodeType(e){return e.object.count>1?e.getTypeFromLength(this.getVectorLength(e)):"float"}setup(e){const t=e.object;let s=null;if(t.count>1){const o=this.minNode.value,i=this.maxNode.value,r=e.getTypeLength(je(o)),a=e.getTypeLength(je(i));et=et||new Ze,tt=tt||new Ze,et.setScalar(0),tt.setScalar(0),r===1?et.setScalar(o):o.isColor?et.set(o.r,o.g,o.b):et.set(o.x,o.y,o.z||0,o.w||0),a===1?tt.setScalar(i):i.isColor?tt.set(i.r,i.g,i.b):tt.set(i.x,i.y,i.z||0,i.w||0);const c=4,u=c*t.count,l=new Float32Array(u);for(let d=0;d<u;d++){const x=d%c,v=et.getComponent(x),C=tt.getComponent(x);l[d]=bo.lerp(v,C,Math.random())}const h=this.getNodeType(e);if(t.count<=4096)s=zn(l,"vec4",t.count).element(In).convert(h);else{const d=new Do(l,4);e.geometry.setAttribute("__range"+this.id,d),s=ln(d).convert(h)}}else s=y(0);return s}}g(Dr);T("RangeNode",Dr);class zr extends V{constructor(e,t,s=[64]){super("void"),this.isComputeNode=!0,this.computeNode=e,this.count=t,this.workgroupSize=s,this.dispatchCount=0,this.version=1,this.updateBeforeType=z.OBJECT,this.updateDispatchCount()}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}updateDispatchCount(){const{count:e,workgroupSize:t}=this;let s=t[0];for(let o=1;o<t.length;o++)s*=t[o];this.dispatchCount=Math.ceil(e/s)}onInit(){}updateBefore({renderer:e}){e.compute(this)}generate(e){const{shaderStage:t}=e;if(t==="compute"){const s=this.computeNode.build(e,"void");s!==""&&e.addLineFlowCode(s)}}}const Sh=(n,e,t)=>M(new zr(M(n),e,t));m("compute",Sh);T("ComputeNode",zr);class it extends V{constructor(e=it.TARGET_DIRECTION,t=null){super(),this.scope=e,this.light=t}setup(){const{scope:e,light:t}=this;let s=null;return e===it.TARGET_DIRECTION&&(s=Ct.transformDirection(an(t).sub(an(t.target)))),s}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}it.TARGET_DIRECTION="targetDirection";const Fr=g(it,it.TARGET_DIRECTION);T("LightNode",it);const Pr=A(n=>{const{lightDistance:e,cutoffDistance:t,decayExponent:s}=n,o=e.pow(s).max(.01).reciprocal();return t.greaterThan(0).cond(o.mul(e.div(t).pow4().oneMinus().clamp().pow2()),o)});class Ur extends Qe{constructor(e=null){super(e),this.cutoffDistanceNode=O(0),this.decayExponentNode=O(0)}update(e){const{light:t}=this;super.update(e),this.cutoffDistanceNode.value=t.distance,this.decayExponentNode.value=t.decay}setup(e){const{colorNode:t,cutoffDistanceNode:s,decayExponentNode:o,light:i}=this,r=e.context.lightingModel,a=Fn(i).sub(ce),c=a.normalize(),u=a.length(),l=Pr({lightDistance:u,cutoffDistance:s,decayExponent:o}),h=t.mul(l),d=e.context.reflectedLight;r.direct({lightDirection:c,lightColor:h,reflectedLight:d,shadowMask:this.shadowMaskNode},e.stack,e)}}T("PointLightNode",Ur);ut(Aa,Ur);class Br extends Qe{constructor(e=null){super(e)}setup(e){super.setup(e);const t=e.context.lightingModel,s=this.colorNode,o=Fr(this.light),i=e.context.reflectedLight;t.direct({lightDirection:o,lightColor:s,reflectedLight:i,shadowMask:this.shadowMaskNode},e.stack,e)}}T("DirectionalLightNode",Br);ut(Ra,Br);const js=new kt,Kt=new kt;let Jt,Zs;class kr extends Qe{constructor(e=null){super(e),this.halfHeight=O(new me),this.halfWidth=O(new me)}update(e){super.update(e);const{light:t}=this,s=e.camera.matrixWorldInverse;Kt.identity(),js.copy(t.matrixWorld),js.premultiply(s),Kt.extractRotation(js),this.halfWidth.value.set(t.width*.5,0,0),this.halfHeight.value.set(0,t.height*.5,0),this.halfWidth.value.applyMatrix4(Kt),this.halfHeight.value.applyMatrix4(Kt)}setup(e){super.setup(e),Jt===void 0&&(e.isAvailable("float32Filterable")?(Jt=oe(Xt.LTC_FLOAT_1),Zs=oe(Xt.LTC_FLOAT_2)):(Jt=oe(Xt.LTC_HALF_1),Zs=oe(Xt.LTC_HALF_2)));const{colorNode:t,light:s}=this,o=e.context.lightingModel,i=Fn(s),r=e.context.reflectedLight;o.directRectArea({lightColor:t,lightPosition:i,halfWidth:this.halfWidth,halfHeight:this.halfHeight,reflectedLight:r,ltc_1:Jt,ltc_2:Zs},e.stack,e)}}T("RectAreaLightNode",kr);ut(Ca,kr);class kn extends Qe{constructor(e=null){super(e),this.coneCosNode=O(0),this.penumbraCosNode=O(0),this.cutoffDistanceNode=O(0),this.decayExponentNode=O(0)}update(e){super.update(e);const{light:t}=this;this.coneCosNode.value=Math.cos(t.angle),this.penumbraCosNode.value=Math.cos(t.angle*(1-t.penumbra)),this.cutoffDistanceNode.value=t.distance,this.decayExponentNode.value=t.decay}getSpotAttenuation(e){const{coneCosNode:t,penumbraCosNode:s}=this;return Fe(t,s,e)}setup(e){super.setup(e);const t=e.context.lightingModel,{colorNode:s,cutoffDistanceNode:o,decayExponentNode:i,light:r}=this,a=Fn(r).sub(ce),c=a.normalize(),u=c.dot(Fr(r)),l=this.getSpotAttenuation(u),h=a.length(),d=Pr({lightDistance:h,cutoffDistance:o,decayExponent:i}),x=s.mul(l).mul(d),v=e.context.reflectedLight;t.direct({lightDirection:c,lightColor:x,reflectedLight:v,shadowMask:this.shadowMaskNode},e.stack,e)}}T("SpotLightNode",kn);ut(Uo,kn);class Mh extends Uo{constructor(e,t,s,o,i,r){super(e,t,s,o,i,r),this.iesMap=null}copy(e,t){return super.copy(e,t),this.iesMap=e.iesMap,this}}class Gr extends kn{getSpotAttenuation(e){const t=this.light.iesMap;let s=null;if(t&&t.isTexture===!0){const o=e.acos().mul(1/Math.PI);s=oe(t,S(o,0),0).r}else s=super.getSpotAttenuation(e);return s}}T("IESSpotLightNode",Gr);ut(Mh,Gr);class Hr extends Qe{constructor(e=null){super(e)}setup({context:e}){e.irradiance.addAssign(this.colorNode)}}T("AmbientLightNode",Hr);ut(wa,Hr);class $r extends Qe{constructor(e=null){super(e),this.lightPositionNode=an(e),this.lightDirectionNode=this.lightPositionNode.normalize(),this.groundColorNode=O(new Tn)}update(e){const{light:t}=this;super.update(e),this.lightPositionNode.object3d=t,this.groundColorNode.value.copy(t.groundColor).multiplyScalar(t.intensity)}setup(e){const{colorNode:t,groundColorNode:s,lightDirectionNode:o}=this,r=Ke.dot(o).mul(.5).add(.5),a=Q(s,t,r);e.context.irradiance.addAssign(a)}}T("HemisphereLightNode",$r);ut(Ea,$r);const Ah=A(n=>{const e=n.uv.mul(2),t=e.x.floor(),s=e.y.floor();return t.add(s).mod(2).sign()});class Wr extends P{constructor(e=xe()){super("float"),this.uvNode=e}setup(){return Ah({uv:this.uvNode})}}const Rh=g(Wr);m("checker",Rh);T("CheckerNode",Wr);const Ch=new Bo;class wh extends de{constructor(e={}){super(),this.normals=!1,this.lights=!1,this.useAlphaToCoverage=!0,this.useColor=e.vertexColors,this.pointWidth=1,this.pointColorNode=null,this.setDefaultValues(Ch),this.setupShaders(),this.setValues(e)}setupShaders(){const e=this.alphaToCoverage,t=this.useColor;this.vertexNode=A(()=>{J(S(),"vUv").assign(xe());const s=ae("instancePosition"),o=j("vec4","mvPos");o.assign(ot.mul(w(s,1)));const i=vt.z.div(vt.w),r=be.mul(o),a=j("vec2","offset");return a.assign(he.xy),a.assign(a.mul(pl)),a.assign(a.div(vt.z)),a.y.assign(a.y.mul(i)),a.assign(a.mul(r.w)),r.assign(r.add(w(a,0,0))),r})(),this.fragmentNode=A(()=>{const s=J(S(),"vUv"),o=j("float","alpha");o.assign(1);const i=s.x,r=s.y,a=i.mul(i).add(r.mul(r));if(e){const u=j("float","dlen");u.assign(a.fwidth()),o.assign(Fe(u.oneMinus(),u.add(1),a).oneMinus())}else a.greaterThan(1).discard();let c;return this.pointColorNode?c=this.pointColorNode:t?c=ae("instanceColor").mul(Pt):c=Pt,w(c,o)})(),this.needsUpdate=!0}get alphaToCoverage(){return this.useAlphaToCoverage}set alphaToCoverage(e){this.useAlphaToCoverage!==e&&(this.useAlphaToCoverage=e,this.setupShaders())}}ne("InstancedPointsNodeMaterial",wh);const Eh=new Ia;class Ih extends de{constructor(e){super(),this.isLineBasicNodeMaterial=!0,this.lights=!1,this.normals=!1,this.setDefaultValues(Eh),this.setValues(e)}}ne("LineBasicNodeMaterial",Ih);const Lh=new ko;class Vh extends de{constructor(e){super(),this.isLineDashedNodeMaterial=!0,this.lights=!1,this.normals=!1,this.setDefaultValues(Lh),this.offsetNode=null,this.dashScaleNode=null,this.dashSizeNode=null,this.gapSizeNode=null,this.setValues(e)}setupVariants(){const e=this.offsetNode,t=this.dashScaleNode?y(this.dashScaleNode):cn,s=this.dashSizeNode?y(this.dashSizeNode):wi,o=this.dashSizeNode?y(this.dashGapNode):Ei;Tt.assign(s),ls.assign(o);const i=J(ae("lineDistance").mul(t));(e?i.add(e):i).mod(Tt.add(ls)).greaterThan(Tt).discard()}}ne("LineDashedNodeMaterial",Vh);const Oh=new ko;class _h extends de{constructor(e={}){super(),this.normals=!1,this.lights=!1,this.setDefaultValues(Oh),this.useAlphaToCoverage=!0,this.useColor=e.vertexColors,this.useDash=e.dashed,this.useWorldUnits=!1,this.dashOffset=0,this.lineWidth=1,this.lineColorNode=null,this.offsetNode=null,this.dashScaleNode=null,this.dashSizeNode=null,this.gapSizeNode=null,this.setValues(e)}setup(e){this.setupShaders(),super.setup(e)}setupShaders(){const e=this.alphaToCoverage,t=this.useColor,s=this.dashed,o=this.worldUnits,i=A(({start:a,end:c})=>{const u=be.element(2).element(2),d=be.element(3).element(2).mul(-.5).div(u).sub(a.z).div(c.z.sub(a.z));return w(Q(a.xyz,c.xyz,d),c.w)});this.vertexNode=A(()=>{Ve("vec2","vUv").assign(xe());const a=ae("instanceStart"),c=ae("instanceEnd"),u=j("vec4","start"),l=j("vec4","end");u.assign(ot.mul(w(a,1))),l.assign(ot.mul(w(c,1))),o&&(Ve("vec3","worldStart").assign(u.xyz),Ve("vec3","worldEnd").assign(l.xyz));const h=vt.z.div(vt.w),d=be.element(2).element(3).equal(-1);K(d,()=>{K(u.z.lessThan(0).and(l.z.greaterThan(0)),()=>{l.assign(i({start:u,end:l}))}).elseif(l.z.lessThan(0).and(u.z.greaterThanEqual(0)),()=>{u.assign(i({start:l,end:u}))})});const x=be.mul(u),v=be.mul(l),C=x.xyz.div(x.w),E=v.xyz.div(v.w),L=E.xy.sub(C.xy).temp();L.x.assign(L.x.mul(h)),L.assign(L.normalize());const b=rs(w());if(o){const I=l.xyz.sub(u.xyz).normalize(),Y=Q(u.xyz,l.xyz,.5).normalize(),W=I.cross(Y).normalize(),G=I.cross(W),$=Ve("vec4","worldPos");$.assign(he.y.lessThan(.5).cond(u,l));const D=_s.mul(.5);$.addAssign(w(he.x.lessThan(0).cond(W.mul(D),W.mul(D).negate()),0)),s||($.addAssign(w(he.y.lessThan(.5).cond(I.mul(D).negate(),I.mul(D)),0)),$.addAssign(w(G.mul(D),0)),K(he.y.greaterThan(1).or(he.y.lessThan(0)),()=>{$.subAssign(w(G.mul(2).mul(D),0))})),b.assign(be.mul($));const Be=rs(f());Be.assign(he.y.lessThan(.5).cond(C,E)),b.z.assign(Be.z.mul(b.w))}else{const I=j("vec2","offset");I.assign(S(L.y,L.x.negate())),L.x.assign(L.x.div(h)),I.x.assign(I.x.div(h)),I.assign(he.x.lessThan(0).cond(I.negate(),I)),K(he.y.lessThan(0),()=>{I.assign(I.sub(L))}).elseif(he.y.greaterThan(1),()=>{I.assign(I.add(L))}),I.assign(I.mul(_s)),I.assign(I.div(vt.w)),b.assign(he.y.lessThan(.5).cond(x,v)),I.assign(I.mul(b.w)),b.assign(b.add(w(I,0,0)))}return b})();const r=A(({p1:a,p2:c,p3:u,p4:l})=>{const h=a.sub(u),d=l.sub(u),x=c.sub(a),v=h.dot(d),C=d.dot(x),E=h.dot(x),L=d.dot(d),I=x.dot(x).mul(L).sub(C.mul(C)),W=v.mul(C).sub(E.mul(L)).div(I).clamp(),G=v.add(C.mul(W)).div(L).clamp();return S(W,G)});this.fragmentNode=A(()=>{const a=Ve("vec2","vUv");if(s){const l=this.offsetNode?y(this.offsetNodeNode):io,h=this.dashScaleNode?y(this.dashScaleNode):cn,d=this.dashSizeNode?y(this.dashSizeNode):wi,x=this.dashSizeNode?y(this.dashGapNode):Ei;Tt.assign(d),ls.assign(x);const v=ae("instanceDistanceStart"),C=ae("instanceDistanceEnd"),E=he.y.lessThan(.5).cond(h.mul(v),cn.mul(C)),L=J(E.add(io)),b=l?L.add(l):L;a.y.lessThan(-1).or(a.y.greaterThan(1)).discard(),b.mod(Tt.add(ls)).greaterThan(Tt).discard()}const c=j("float","alpha");if(c.assign(1),o){const l=Ve("vec3","worldStart"),h=Ve("vec3","worldEnd"),d=Ve("vec4","worldPos").xyz.normalize().mul(1e5),x=h.sub(l),v=r({p1:l,p2:h,p3:f(0,0,0),p4:d}),C=l.add(x.mul(v.x)),E=d.mul(v.y),I=C.sub(E).length().div(_s);if(!s)if(e){const Y=I.fwidth();c.assign(Fe(Y.negate().add(.5),Y.add(.5),I).oneMinus())}else I.greaterThan(.5).discard()}else if(e){const l=a.x,h=a.y.greaterThan(0).cond(a.y.sub(1),a.y.add(1)),d=l.mul(l).add(h.mul(h)),x=j("float","dlen");x.assign(d.fwidth()),K(a.y.abs().greaterThan(1),()=>{c.assign(Fe(x.oneMinus(),x.add(1),d).oneMinus())})}else K(a.y.abs().greaterThan(1),()=>{const l=a.x,h=a.y.greaterThan(0).cond(a.y.sub(1),a.y.add(1));l.mul(l).add(h.mul(h)).greaterThan(1).discard()});let u;if(this.lineColorNode)u=this.lineColorNode;else if(t){const l=ae("instanceColorStart"),h=ae("instanceColorEnd");u=he.y.lessThan(.5).cond(l,h).mul(Pt)}else u=Pt;return w(u,c)})()}get worldUnits(){return this.useWorldUnits}set worldUnits(e){this.useWorldUnits!==e&&(this.useWorldUnits=e,this.needsUpdate=!0)}get dashed(){return this.useDash}set dashed(e){this.useDash!==e&&(this.useDash=e,this.needsUpdate=!0)}get alphaToCoverage(){return this.useAlphaToCoverage}set alphaToCoverage(e){this.useAlphaToCoverage!==e&&(this.useAlphaToCoverage=e,this.needsUpdate=!0)}}ne("Line2NodeMaterial",_h);const bh=new La;class Dh extends de{constructor(e){super(),this.lights=!1,this.isMeshNormalNodeMaterial=!0,this.setDefaultValues(bh),this.setValues(e)}setupDiffuseColor(){const e=this.opacityNode?y(this.opacityNode):Ci;H.assign(w(ur(Z),e))}}ne("MeshNormalNodeMaterial",Dh);const zh=new Va;class Fh extends de{constructor(e){super(),this.isMeshBasicNodeMaterial=!0,this.lights=!1,this.setDefaultValues(zh),this.setValues(e)}}ne("MeshBasicNodeMaterial",Fh);const Bt=A(({f0:n,f90:e,dotVH:t})=>{const s=t.mul(-5.55473).sub(6.98316).mul(t).exp2();return n.mul(s.oneMinus()).add(e.mul(s))}),Mt=A(n=>n.diffuseColor.mul(1/Math.PI)),Ph=()=>y(.25),Uh=A(({dotNH:n})=>sn.mul(y(.5)).add(1).mul(y(1/Math.PI)).mul(n.pow(sn))),Bh=A(({lightDirection:n})=>{const e=n.add(X).normalize(),t=Z.dot(e).clamp(),s=X.dot(e).clamp(),o=Bt({f0:Se,f90:1,dotVH:s}),i=Ph(),r=Uh({dotNH:t});return o.mul(i).mul(r)});class qr extends vs{constructor(e=!0){super(),this.specular=e}direct({lightDirection:e,lightColor:t,reflectedLight:s}){const i=Z.dot(e).clamp().mul(t);s.directDiffuse.addAssign(i.mul(Mt({diffuseColor:H.rgb}))),this.specular===!0&&s.directSpecular.addAssign(i.mul(Bh({lightDirection:e})).mul(ju))}indirectDiffuse({irradiance:e,reflectedLight:t}){t.indirectDiffuse.addAssign(e.mul(Mt({diffuseColor:H})))}}const kh=new Oa;class Gh extends de{constructor(e){super(),this.isMeshLambertNodeMaterial=!0,this.lights=!0,this.setDefaultValues(kh),this.setValues(e)}setupLightingModel(){return new qr(!1)}}ne("MeshLambertNodeMaterial",Gh);const Hh=new _a;class $h extends de{constructor(e){super(),this.isMeshPhongNodeMaterial=!0,this.lights=!0,this.shininessNode=null,this.specularNode=null,this.setDefaultValues(Hh),this.setValues(e)}setupLightingModel(){return new qr}setupVariants(){const e=(this.shininessNode?y(this.shininessNode):$u).max(1e-4);sn.assign(e);const t=this.specularNode||qu;Se.assign(t)}copy(e){return this.shininessNode=e.shininessNode,this.specularNode=e.specularNode,super.copy(e)}}ne("MeshPhongNodeMaterial",$h);const Wh=A(()=>{const n=hs.dFdx().abs().max(hs.dFdy().abs());return n.x.max(n.y).max(n.z)}),Xr=A(n=>{const{roughness:e}=n,t=Wh();let s=e.max(.0525);return s=s.add(t),s=s.min(1),s}),qh=A(({alpha:n,dotNL:e,dotNV:t})=>{const s=n.pow2(),o=e.mul(s.add(s.oneMinus().mul(t.pow2())).sqrt()),i=t.mul(s.add(s.oneMinus().mul(e.pow2())).sqrt());return qe(.5,o.add(i).max(ui))}).setLayout({name:"V_GGX_SmithCorrelated",type:"float",inputs:[{name:"alpha",type:"float"},{name:"dotNL",type:"float"},{name:"dotNV",type:"float"}]}),Xh=A(({alphaT:n,alphaB:e,dotTV:t,dotBV:s,dotTL:o,dotBL:i,dotNV:r,dotNL:a})=>{const c=a.mul(f(n.mul(t),e.mul(s),r).length()),u=r.mul(f(n.mul(o),e.mul(i),a).length());return qe(.5,c.add(u)).saturate()}).setLayout({name:"V_GGX_SmithCorrelated_Anisotropic",type:"float",inputs:[{name:"alphaT",type:"float",qualifier:"in"},{name:"alphaB",type:"float",qualifier:"in"},{name:"dotTV",type:"float",qualifier:"in"},{name:"dotBV",type:"float",qualifier:"in"},{name:"dotTL",type:"float",qualifier:"in"},{name:"dotBL",type:"float",qualifier:"in"},{name:"dotNV",type:"float",qualifier:"in"},{name:"dotNL",type:"float",qualifier:"in"}]}),jh=A(({alpha:n,dotNH:e})=>{const t=n.pow2(),s=e.pow2().mul(t.oneMinus()).oneMinus();return t.div(s.pow2()).mul(1/Math.PI)}).setLayout({name:"D_GGX",type:"float",inputs:[{name:"alpha",type:"float"},{name:"dotNH",type:"float"}]}),Zh=y(1/Math.PI),Yh=A(({alphaT:n,alphaB:e,dotNH:t,dotTH:s,dotBH:o})=>{const i=n.mul(e),r=f(e.mul(s),n.mul(o),i.mul(t)),a=r.dot(r),c=i.div(a);return Zh.mul(i.mul(c.pow2()))}).setLayout({name:"D_GGX_Anisotropic",type:"float",inputs:[{name:"alphaT",type:"float",qualifier:"in"},{name:"alphaB",type:"float",qualifier:"in"},{name:"dotNH",type:"float",qualifier:"in"},{name:"dotTH",type:"float",qualifier:"in"},{name:"dotBH",type:"float",qualifier:"in"}]}),wo=A(n=>{const{lightDirection:e,f0:t,f90:s,roughness:o,f:i,USE_IRIDESCENCE:r,USE_ANISOTROPY:a}=n,c=n.normalView||Z,u=o.pow2(),l=e.add(X).normalize(),h=c.dot(e).clamp(),d=c.dot(X).clamp(),x=c.dot(l).clamp(),v=X.dot(l).clamp();let C=Bt({f0:t,f90:s,dotVH:v}),E,L;if(Qn(r)&&(C=Vn.mix(C,i)),Qn(a)){const b=ts.dot(e),I=ts.dot(X),Y=ts.dot(l),W=yt.dot(e),G=yt.dot(X),$=yt.dot(l);E=Xh({alphaT:tn,alphaB:u,dotTV:I,dotBV:G,dotTL:b,dotBL:W,dotNV:d,dotNL:h}),L=Yh({alphaT:tn,alphaB:u,dotNH:x,dotTH:Y,dotBH:$})}else E=qh({alpha:u,dotNL:h,dotNV:d}),L=jh({alpha:u,dotNH:x});return C.mul(E).mul(L)}),jr=A(({roughness:n,dotNV:e})=>{const t=w(-1,-.0275,-.572,.022),s=w(1,.0425,1.04,-.04),o=n.mul(t).add(s),i=o.x.mul(o.x).min(e.mul(-9.28).exp2()).mul(o.x).add(o.y);return S(-1.04,1.04).mul(i).add(o.zw)}).setLayout({name:"DFGApprox",type:"vec2",inputs:[{name:"roughness",type:"float"},{name:"dotNV",type:"vec3"}]}),Zr=A(n=>{const{dotNV:e,specularColor:t,specularF90:s,roughness:o}=n,i=jr({dotNV:e,roughness:o});return t.mul(i.x).add(s.mul(i.y))}),Kh=A(({f:n,f90:e,dotVH:t})=>{const s=t.oneMinus().saturate(),o=s.mul(s),i=s.mul(o,o).clamp(0,.9999);return n.sub(f(e).mul(i)).div(i.oneMinus())}).setLayout({name:"Schlick_to_F0",type:"vec3",inputs:[{name:"f",type:"vec3"},{name:"f90",type:"float"},{name:"dotVH",type:"float"}]}),Jh=A(({roughness:n,dotNH:e})=>{const t=n.pow2(),s=y(1).div(t),i=e.pow2().oneMinus().max(.0078125);return y(2).add(s).mul(i.pow(s.mul(.5))).div(2*Math.PI)}).setLayout({name:"D_Charlie",type:"float",inputs:[{name:"roughness",type:"float"},{name:"dotNH",type:"float"}]}),Qh=A(({dotNV:n,dotNL:e})=>y(1).div(y(4).mul(e.add(n).sub(e.mul(n))))).setLayout({name:"V_Neubelt",type:"float",inputs:[{name:"dotNV",type:"float"},{name:"dotNL",type:"float"}]}),ep=A(({lightDirection:n})=>{const e=n.add(X).normalize(),t=Z.dot(n).clamp(),s=Z.dot(X).clamp(),o=Z.dot(e).clamp(),i=Jh({roughness:Ln,dotNH:o}),r=Qh({dotNV:s,dotNL:t});return pt.mul(i).mul(r)}),tp=A(({N:n,V:e,roughness:t})=>{const i=.0078125,r=n.dot(e).saturate(),a=S(t,r.oneMinus().sqrt());return a.assign(a.mul(.984375).add(i)),a}).setLayout({name:"LTC_Uv",type:"vec2",inputs:[{name:"N",type:"vec3"},{name:"V",type:"vec3"},{name:"roughness",type:"float"}]}),sp=A(({f:n})=>{const e=n.length();return pe(e.mul(e).add(n.z).div(e.add(1)),0)}).setLayout({name:"LTC_ClippedSphereFormFactor",type:"float",inputs:[{name:"f",type:"vec3"}]}),Qt=A(({v1:n,v2:e})=>{const t=n.dot(e),s=t.abs().toVar(),o=s.mul(.0145206).add(.4965155).mul(s).add(.8543985).toVar(),i=s.add(4.1616724).mul(s).add(3.417594).toVar(),r=o.div(i),a=t.greaterThan(0).cond(r,pe(t.mul(t).oneMinus(),1e-7).inverseSqrt().mul(.5).sub(r));return n.cross(e).mul(a)}).setLayout({name:"LTC_EdgeVectorFormFactor",type:"vec3",inputs:[{name:"v1",type:"vec3"},{name:"v2",type:"vec3"}]}),Eo=A(({N:n,V:e,P:t,mInv:s,p0:o,p1:i,p2:r,p3:a})=>{const c=i.sub(o).toVar(),u=a.sub(o).toVar(),l=c.cross(u),h=f().toVar();return K(l.dot(t.sub(o)).greaterThanEqual(0),()=>{const d=e.sub(n.mul(e.dot(n))).normalize(),x=n.cross(d).negate(),v=s.mul(le(d,x,n).transpose()).toVar(),C=v.mul(o.sub(t)).normalize().toVar(),E=v.mul(i.sub(t)).normalize().toVar(),L=v.mul(r.sub(t)).normalize().toVar(),b=v.mul(a.sub(t)).normalize().toVar(),I=f(0).toVar();I.addAssign(Qt({v1:C,v2:E})),I.addAssign(Qt({v1:E,v2:L})),I.addAssign(Qt({v1:L,v2:b})),I.addAssign(Qt({v1:b,v2:C})),h.assign(f(sp({f:I})))}),h}).setLayout({name:"LTC_Evaluate",type:"vec3",inputs:[{name:"N",type:"vec3"},{name:"V",type:"vec3"},{name:"P",type:"vec3"},{name:"mInv",type:"mat3"},{name:"p0",type:"vec3"},{name:"p1",type:"vec3"},{name:"p2",type:"vec3"},{name:"p3",type:"vec3"}]}),Io=A(([n,e,t,s,o])=>{const i=f(fi(e.negate(),zt(n),qe(1,s))),r=f(xt(o[0].xyz),xt(o[1].xyz),xt(o[2].xyz));return zt(i).mul(t.mul(r))}).setLayout({name:"getVolumeTransmissionRay",type:"vec3",inputs:[{name:"n",type:"vec3"},{name:"v",type:"vec3"},{name:"thickness",type:"float"},{name:"ior",type:"float"},{name:"modelMatrix",type:"mat4"}]}),np=A(([n,e])=>n.mul(nt(e.mul(2).sub(2),0,1))).setLayout({name:"applyIorToRoughness",type:"float",inputs:[{name:"roughness",type:"float"},{name:"ior",type:"float"}]}),op=Xi(),Lo=A(([n,e,t])=>{const s=op.uv(n),o=Ss(y(pn.x)).mul(np(e,t));return s.bicubic(o)}),Vo=A(([n,e,t])=>(K(t.notEqual(0),()=>{const s=hi(e).negate().div(t);return di(s.negate().mul(n))}),f(1))).setLayout({name:"volumeAttenuation",type:"vec3",inputs:[{name:"transmissionDistance",type:"float"},{name:"attenuationColor",type:"vec3"},{name:"attenuationDistance",type:"float"}]}),ip=A(([n,e,t,s,o,i,r,a,c,u,l,h,d,x,v])=>{let C,E;if(v){C=w().toVar(),E=f().toVar();const W=l.sub(1).mul(v.mul(.025)),G=f(l.sub(W),l,l.add(W));Ee({start:0,end:3},({i:$})=>{const D=G.element($),Be=Io(n,e,h,D,a),lt=r.add(Be),qt=u.mul(c.mul(w(lt,1))),dt=S(qt.xy.div(qt.w)).toVar();dt.addAssign(1),dt.divAssign(2),dt.assign(S(dt.x,dt.y.oneMinus()));const Hn=Lo(dt,t,D);C.element($).assign(Hn.element($)),C.a.addAssign(Hn.a),E.element($).assign(s.element($).mul(Vo(xt(Be),d,x).element($)))}),C.a.divAssign(3)}else{const W=Io(n,e,h,l,a),G=r.add(W),$=u.mul(c.mul(w(G,1))),D=S($.xy.div($.w)).toVar();D.addAssign(1),D.divAssign(2),D.assign(S(D.x,D.y.oneMinus())),C=Lo(D,t,l),E=s.mul(Vo(xt(W),d,x))}const L=E.rgb.mul(C.rgb),b=n.dot(e).clamp(),I=f(Zr({dotNV:b,specularColor:o,specularF90:i,roughness:t})),Y=E.r.add(E.g,E.b).div(3);return w(I.oneMinus().mul(L),C.a.oneMinus().mul(Y).oneMinus())}),rp=le(3.2404542,-.969266,.0556434,-1.5371385,1.8760108,-.2040259,-.4985314,.041556,1.0572252),ap=n=>{const e=n.sqrt();return f(1).add(e).div(f(1).sub(e))},Oo=(n,e)=>n.sub(e).div(n.add(e)).pow2(),cp=(n,e)=>{const t=n.mul(2*Math.PI*1e-9),s=f(54856e-17,44201e-17,52481e-17),o=f(1681e3,1795300,2208400),i=f(43278e5,93046e5,66121e5),r=y(9747e-17*Math.sqrt(2*Math.PI*45282e5)).mul(t.mul(2239900).add(e.x).cos()).mul(t.pow2().mul(-45282e5).exp());let a=s.mul(i.mul(2*Math.PI).sqrt()).mul(o.mul(t).add(e).cos()).mul(t.pow2().negate().mul(i).exp());return a=f(a.x.add(r),a.y,a.z).div(10685e-11),rp.mul(a)},up=A(({outsideIOR:n,eta2:e,cosTheta1:t,thinFilmThickness:s,baseF0:o})=>{const i=Q(n,e,Fe(0,.03,s)),r=n.div(i).pow2().mul(y(1).sub(t.pow2())),c=y(1).sub(r).sqrt(),u=Oo(i,n),l=Bt({f0:u,f90:1,dotVH:t}),h=l.oneMinus(),d=i.lessThan(n).cond(Math.PI,0),x=y(Math.PI).sub(d),v=ap(o.clamp(0,.9999)),C=Oo(v,i.toVec3()),E=Bt({f0:C,f90:1,dotVH:c}),L=f(v.x.lessThan(i).cond(Math.PI,0),v.y.lessThan(i).cond(Math.PI,0),v.z.lessThan(i).cond(Math.PI,0)),b=i.mul(s,c,2),I=f(x).add(L),Y=l.mul(E).clamp(1e-5,.9999),W=Y.sqrt(),G=h.pow2().mul(E).div(f(1).sub(Y));let D=l.add(G),Be=G.sub(h);for(let lt=1;lt<=2;++lt){Be=Be.mul(W);const qt=cp(y(lt).mul(b),y(lt).mul(I)).mul(2);D=D.add(Be.mul(qt))}return D.max(f(0))}).setLayout({name:"evalIridescence",type:"vec3",inputs:[{name:"outsideIOR",type:"float"},{name:"eta2",type:"float"},{name:"cosTheta1",type:"float"},{name:"thinFilmThickness",type:"float"},{name:"baseF0",type:"vec3"}]}),lp=A(({normal:n,viewDir:e,roughness:t})=>{const s=n.dot(e).saturate(),o=t.pow2(),i=Re(t.lessThan(.25),y(-339.2).mul(o).add(y(161.4).mul(t)).sub(25.9),y(-8.48).mul(o).add(y(14.3).mul(t)).sub(9.95)),r=Re(t.lessThan(.25),y(44).mul(o).sub(y(23.7).mul(t)).add(3.26),y(1.97).mul(o).sub(y(3.27).mul(t)).add(.72));return Re(t.lessThan(.25),0,y(.1).mul(t).sub(.025)).add(i.mul(s).add(r).exp()).mul(1/Math.PI).saturate()}),Ys=f(.04),Ks=y(1);class Gn extends vs{constructor(e=!1,t=!1,s=!1,o=!1,i=!1,r=!1){super(),this.clearcoat=e,this.sheen=t,this.iridescence=s,this.anisotropy=o,this.transmission=i,this.dispersion=r,this.clearcoatRadiance=null,this.clearcoatSpecularDirect=null,this.clearcoatSpecularIndirect=null,this.sheenSpecularDirect=null,this.sheenSpecularIndirect=null,this.iridescenceFresnel=null,this.iridescenceF0=null}start(e){if(this.clearcoat===!0&&(this.clearcoatRadiance=f().temp("clearcoatRadiance"),this.clearcoatSpecularDirect=f().temp("clearcoatSpecularDirect"),this.clearcoatSpecularIndirect=f().temp("clearcoatSpecularIndirect")),this.sheen===!0&&(this.sheenSpecularDirect=f().temp("sheenSpecularDirect"),this.sheenSpecularIndirect=f().temp("sheenSpecularIndirect")),this.iridescence===!0){const t=Z.dot(X).clamp();this.iridescenceFresnel=up({outsideIOR:y(1),eta2:si,cosTheta1:t,thinFilmThickness:ni,baseF0:Se}),this.iridescenceF0=Kh({f:this.iridescenceFresnel,f90:1,dotVH:t})}if(this.transmission===!0){const t=un,s=Mi.sub(un).normalize(),o=Ri;e.backdrop=ip(o,s,Ge,H,Se,us,t,Ft,Ct,be,ss,oi,ri,ii,this.dispersion?ai:null),e.backdropAlpha=nn,H.a.mulAssign(Q(1,e.backdrop.a,nn))}}computeMultiscattering(e,t,s){const o=Z.dot(X).clamp(),i=jr({roughness:Ge,dotNV:o}),a=(this.iridescenceF0?Vn.mix(Se,this.iridescenceF0):Se).mul(i.x).add(s.mul(i.y)),u=i.x.add(i.y).oneMinus(),l=Se.add(Se.oneMinus().mul(.047619)),h=a.mul(l).div(u.mul(l).oneMinus());e.addAssign(a),t.addAssign(h.mul(u))}direct({lightDirection:e,lightColor:t,reflectedLight:s}){const i=Z.dot(e).clamp().mul(t);if(this.sheen===!0&&this.sheenSpecularDirect.addAssign(i.mul(ep({lightDirection:e}))),this.clearcoat===!0){const a=mt.dot(e).clamp().mul(t);this.clearcoatSpecularDirect.addAssign(a.mul(wo({lightDirection:e,f0:Ys,f90:Ks,roughness:cs,normalView:mt})))}s.directDiffuse.addAssign(i.mul(Mt({diffuseColor:H.rgb}))),s.directSpecular.addAssign(i.mul(wo({lightDirection:e,f0:Se,f90:1,roughness:Ge,iridescence:this.iridescence,f:this.iridescenceFresnel,USE_IRIDESCENCE:this.iridescence,USE_ANISOTROPY:this.anisotropy})))}directRectArea({lightColor:e,lightPosition:t,halfWidth:s,halfHeight:o,reflectedLight:i,ltc_1:r,ltc_2:a}){const c=t.add(s).sub(o),u=t.sub(s).sub(o),l=t.sub(s).add(o),h=t.add(s).add(o),d=Z,x=X,v=ce.toVar(),C=tp({N:d,V:x,roughness:Ge}),E=r.uv(C).toVar(),L=a.uv(C).toVar(),b=le(f(E.x,0,E.y),f(0,1,0),f(E.z,0,E.w)).toVar(),I=Se.mul(L.x).add(Se.oneMinus().mul(L.y)).toVar();i.directSpecular.addAssign(e.mul(I).mul(Eo({N:d,V:x,P:v,mInv:b,p0:c,p1:u,p2:l,p3:h}))),i.directDiffuse.addAssign(e.mul(H).mul(Eo({N:d,V:x,P:v,mInv:le(1,0,0,0,1,0,0,0,1),p0:c,p1:u,p2:l,p3:h})))}indirectDiffuse({irradiance:e,reflectedLight:t}){t.indirectDiffuse.addAssign(e.mul(Mt({diffuseColor:H})))}indirectSpecular({radiance:e,iblIrradiance:t,reflectedLight:s}){if(this.sheen===!0&&this.sheenSpecularIndirect.addAssign(t.mul(pt,lp({normal:Z,viewDir:X,roughness:Ln}))),this.clearcoat===!0){const u=mt.dot(X).clamp(),l=Zr({dotNV:u,specularColor:Ys,specularF90:Ks,roughness:cs});this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(l))}const o=f().temp("singleScattering"),i=f().temp("multiScattering"),r=t.mul(1/Math.PI);this.computeMultiscattering(o,i,us);const a=o.add(i),c=H.mul(a.r.max(a.g).max(a.b).oneMinus());s.indirectSpecular.addAssign(e.mul(o)),s.indirectSpecular.addAssign(i.mul(r)),s.indirectDiffuse.addAssign(c.mul(r))}ambientOcclusion({ambientOcclusion:e,reflectedLight:t}){const o=Z.dot(X).clamp().add(e),i=Ge.mul(-16).oneMinus().negate().exp2(),r=e.sub(o.pow(i).oneMinus()).clamp();this.clearcoat===!0&&this.clearcoatSpecularIndirect.mulAssign(e),this.sheen===!0&&this.sheenSpecularIndirect.mulAssign(e),t.indirectDiffuse.mulAssign(e),t.indirectSpecular.mulAssign(r)}finish(e){const{outgoingLight:t}=e;if(this.clearcoat===!0){const s=mt.dot(X).clamp(),o=Bt({dotVH:s,f0:Ys,f90:Ks}),i=t.mul(en.mul(o).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(en));t.assign(i)}if(this.sheen===!0){const s=pt.r.max(pt.g).max(pt.b).mul(.157).oneMinus(),o=t.mul(s).add(this.sheenSpecularDirect,this.sheenSpecularIndirect);t.assign(o)}}}const dp=new ba;class Yr extends de{constructor(e){super(),this.isMeshStandardNodeMaterial=!0,this.emissiveNode=null,this.metalnessNode=null,this.roughnessNode=null,this.setDefaultValues(dp),this.setValues(e)}setupLightingModel(){return new Gn}setupSpecular(){const e=Q(f(.04),H.rgb,as);Se.assign(e),us.assign(1)}setupVariants(){const e=this.metalnessNode?y(this.metalnessNode):Yu;as.assign(e);let t=this.roughnessNode?y(this.roughnessNode):Zu;t=Xr({roughness:t}),Ge.assign(t),this.setupSpecular(),H.assign(w(H.rgb.mul(e.oneMinus()),H.a))}copy(e){return this.emissiveNode=e.emissiveNode,this.metalnessNode=e.metalnessNode,this.roughnessNode=e.roughnessNode,super.copy(e)}}ne("MeshStandardNodeMaterial",Yr);const hp=new Da;class Kr extends Yr{constructor(e){super(),this.isMeshPhysicalNodeMaterial=!0,this.clearcoatNode=null,this.clearcoatRoughnessNode=null,this.clearcoatNormalNode=null,this.sheenNode=null,this.sheenRoughnessNode=null,this.iridescenceNode=null,this.iridescenceIORNode=null,this.iridescenceThicknessNode=null,this.specularIntensityNode=null,this.specularColorNode=null,this.iorNode=null,this.transmissionNode=null,this.thicknessNode=null,this.attenuationDistanceNode=null,this.attenuationColorNode=null,this.dispersionNode=null,this.anisotropyNode=null,this.setDefaultValues(hp),this.setValues(e)}get useClearcoat(){return this.clearcoat>0||this.clearcoatNode!==null}get useIridescence(){return this.iridescence>0||this.iridescenceNode!==null}get useSheen(){return this.sheen>0||this.sheenNode!==null}get useAnisotropy(){return this.anisotropy>0||this.anisotropyNode!==null}get useTransmission(){return this.transmission>0||this.transmissionNode!==null}get useDispersion(){return this.dispersion>0||this.dispersionNode!==null}setupSpecular(){const e=this.iorNode?y(this.iorNode):ll;ss.assign(e),Se.assign(Q(He(gi(ss.sub(1).div(ss.add(1))).mul(Xu),f(1)).mul(oo),H.rgb,as)),us.assign(Q(oo,1,as))}setupLightingModel(){return new Gn(this.useClearcoat,this.useSheen,this.useIridescence,this.useAnisotropy,this.useTransmission,this.useDispersion)}setupVariants(e){if(super.setupVariants(e),this.useClearcoat){const t=this.clearcoatNode?y(this.clearcoatNode):Ju,s=this.clearcoatRoughnessNode?y(this.clearcoatRoughnessNode):Qu;en.assign(t),cs.assign(Xr({roughness:s}))}if(this.useSheen){const t=this.sheenNode?f(this.sheenNode):sl,s=this.sheenRoughnessNode?y(this.sheenRoughnessNode):nl;pt.assign(t),Ln.assign(s)}if(this.useIridescence){const t=this.iridescenceNode?y(this.iridescenceNode):il,s=this.iridescenceIORNode?y(this.iridescenceIORNode):rl,o=this.iridescenceThicknessNode?y(this.iridescenceThicknessNode):al;Vn.assign(t),si.assign(s),ni.assign(o)}if(this.useAnisotropy){const t=(this.anisotropyNode?S(this.anisotropyNode):ol).toVar();st.assign(t.length()),K(st.equal(0),()=>{t.assign(S(1,0))}).else(()=>{t.divAssign(S(st)),st.assign(st.saturate())}),tn.assign(st.pow2().mix(Ge.pow2(),1)),ts.assign(gt[0].mul(t.x).add(gt[1].mul(t.y))),yt.assign(gt[1].mul(t.x).sub(gt[0].mul(t.y)))}if(this.useTransmission){const t=this.transmissionNode?y(this.transmissionNode):cl,s=this.thicknessNode?y(this.thicknessNode):ul,o=this.attenuationDistanceNode?y(this.attenuationDistanceNode):dl,i=this.attenuationColorNode?f(this.attenuationColorNode):hl;if(nn.assign(t),oi.assign(s),ii.assign(o),ri.assign(i),this.useDispersion){const r=this.dispersionNode?y(this.dispersionNode):ml;ai.assign(r)}}}setupNormal(e){super.setupNormal(e);const t=this.clearcoatNormalNode?f(this.clearcoatNormalNode):el;mt.assign(t)}copy(e){return this.clearcoatNode=e.clearcoatNode,this.clearcoatRoughnessNode=e.clearcoatRoughnessNode,this.clearcoatNormalNode=e.clearcoatNormalNode,this.sheenNode=e.sheenNode,this.sheenRoughnessNode=e.sheenRoughnessNode,this.iridescenceNode=e.iridescenceNode,this.iridescenceIORNode=e.iridescenceIORNode,this.iridescenceThicknessNode=e.iridescenceThicknessNode,this.specularIntensityNode=e.specularIntensityNode,this.specularColorNode=e.specularColorNode,this.transmissionNode=e.transmissionNode,this.thicknessNode=e.thicknessNode,this.attenuationDistanceNode=e.attenuationDistanceNode,this.attenuationColorNode=e.attenuationColorNode,this.dispersionNode=e.dispersionNode,this.anisotropyNode=e.anisotropyNode,super.copy(e)}}ne("MeshPhysicalNodeMaterial",Kr);class pp extends Gn{constructor(e,t,s,o){super(e,t,s),this.useSSS=o}direct({lightDirection:e,lightColor:t,reflectedLight:s},o,i){if(this.useSSS===!0){const r=i.material,{thicknessColorNode:a,thicknessDistortionNode:c,thicknessAmbientNode:u,thicknessAttenuationNode:l,thicknessPowerNode:h,thicknessScaleNode:d}=r,x=e.add(Z.mul(c)).normalize(),v=y(X.dot(x.negate()).saturate().pow(h).mul(d)),C=f(v.add(u).mul(a));s.directDiffuse.addAssign(C.mul(l.mul(t)))}super.direct({lightDirection:e,lightColor:t,reflectedLight:s},o,i)}}class mp extends Kr{constructor(e){super(e),this.thicknessColorNode=null,this.thicknessDistortionNode=y(.1),this.thicknessAmbientNode=y(0),this.thicknessAttenuationNode=y(.1),this.thicknessPowerNode=y(2),this.thicknessScaleNode=y(10)}get useSSS(){return this.thicknessColorNode!==null}setupLightingModel(){return new pp(this.useClearcoat,this.useSheen,this.useIridescence,this.useSSS)}copy(e){return this.thicknessColorNode=e.thicknessColorNode,this.thicknessDistortionNode=e.thicknessDistortionNode,this.thicknessAmbientNode=e.thicknessAmbientNode,this.thicknessAttenuationNode=e.thicknessAttenuationNode,this.thicknessPowerNode=e.thicknessPowerNode,this.thicknessScaleNode=e.thicknessScaleNode,super.copy(e)}}ne("MeshSSSNodeMaterial",mp);const gp=A(({normal:n,lightDirection:e,builder:t})=>{const s=n.dot(e),o=S(s.mul(.5).add(.5),0);if(t.material.gradientMap){const i=We("gradientMap","texture").context({getUV:()=>o});return f(i.r)}else{const i=o.fwidth().mul(.5);return Q(f(.7),f(1),Fe(y(.7).sub(i.x),y(.7).add(i.x),o.x))}});class fp extends vs{direct({lightDirection:e,lightColor:t,reflectedLight:s},o,i){const r=gp({normal:hs,lightDirection:e,builder:i}).mul(t);s.directDiffuse.addAssign(r.mul(Mt({diffuseColor:H.rgb})))}indirectDiffuse({irradiance:e,reflectedLight:t}){t.indirectDiffuse.addAssign(e.mul(Mt({diffuseColor:H})))}}const Np=new za;class yp extends de{constructor(e){super(),this.isMeshToonNodeMaterial=!0,this.lights=!0,this.setDefaultValues(Np),this.setValues(e)}setupLightingModel(){return new fp}}ne("MeshToonNodeMaterial",yp);const Tp=new Fa;class xp extends de{constructor(e){super(),this.lights=!1,this.isMeshMatcapNodeMaterial=!0,this.setDefaultValues(Tp),this.setValues(e)}setupVariants(e){const t=td;let s;e.material.matcap?s=We("matcap","texture").context({getUV:()=>t}):s=f(Q(.2,.8,t.y)),H.rgb.mulAssign(s.rgb)}}ne("MeshMatcapNodeMaterial",xp);const vp=new Bo;class Sp extends de{constructor(e){super(),this.isPointsNodeMaterial=!0,this.lights=!1,this.normals=!1,this.transparent=!0,this.sizeNode=null,this.setDefaultValues(vp),this.setValues(e)}copy(e){return this.sizeNode=e.sizeNode,super.copy(e)}}ne("PointsNodeMaterial",Sp);const Mp=new Pa;class Ap extends de{constructor(e){super(),this.isSpriteNodeMaterial=!0,this.lights=!1,this.normals=!1,this.positionNode=null,this.rotationNode=null,this.scaleNode=null,this.setDefaultValues(Mp),this.setValues(e)}setupPosition({object:e,context:t}){const{positionNode:s,rotationNode:o,scaleNode:i}=this,r=ie;let a=ot.mul(f(s||0)),c=S(Ft[0].xyz.length(),Ft[1].xyz.length());i!==null&&(c=c.mul(i));let u=r.xy;e.center&&e.center.isVector2===!0&&(u=u.sub(O(e.center).sub(.5))),u=u.mul(c);const l=y(o||tl),h=u.rotate(l);a=w(a.xy.add(h),a.zw);const d=be.mul(a);return t.vertex=r,d}copy(e){return this.positionNode=e.positionNode,this.rotationNode=e.rotationNode,this.scaleNode=e.scaleNode,super.copy(e)}}ne("SpriteNodeMaterial",Ap);class Rp extends vs{constructor(){super(),this.shadowNode=y(1).toVar("shadowMask")}direct({shadowMask:e}){this.shadowNode.mulAssign(e)}finish(e){H.a.mulAssign(this.shadowNode.oneMinus()),e.outgoingLight.rgb.assign(H.rgb)}}const Cp=new Ua;class wp extends de{constructor(e){super(),this.isShadowNodeMaterial=!0,this.lights=!0,this.setDefaultValues(Cp),this.setValues(e)}setupLightingModel(){return new Rp}}ne("ShadowNodeMaterial",wp);class Ep extends de{constructor(e={}){super(),this.normals=!1,this.lights=!1,this.isVolumeNodeMaterial=!0,this.testNode=null,this.setValues(e)}setup(e){const t=fd(this.map,null,0),s=A(({orig:o,dir:i})=>{const r=f(-.5),a=f(.5),c=i.reciprocal(),u=r.sub(o).mul(c),l=a.sub(o).mul(c),h=He(u,l),d=pe(u,l),x=pe(h.x,pe(h.y,h.z)),v=He(d.x,He(d.y,d.z));return S(x,v)});this.fragmentNode=A(()=>{const o=J(f(ku.mul(w(Mi,1)))),r=J(he.sub(o)).normalize(),a=j("vec2","bounds").assign(s({orig:o,dir:r}));a.x.greaterThan(a.y).discard(),a.assign(S(pe(a.x,0),a.y));const c=j("vec3","p").assign(o.add(a.x.mul(r))),u=j("vec3","inc").assign(f(r.abs().reciprocal())),l=j("float","delta").assign(He(u.x,He(u.y,u.z)));l.divAssign(We("steps","float"));const h=j("vec4","ac").assign(w(We("base","color"),0));return Ee({type:"float",start:a.x,end:a.y,update:"+= delta"},()=>{const d=j("float","d").assign(t.uv(c.add(.5)).r);this.testNode!==null?this.testNode({map:t,mapValue:d,probe:c,finalColor:h}).append():(h.a.assign(1),Fi()),c.addAssign(r.mul(l))}),h.a.equal(0).discard(),w(h)})(),super.setup(e)}}ne("VolumeNodeMaterial",Ep);const Lp={name:"QuantizationShader",uniforms:{tDiffuse:{value:null}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform sampler2D tDiffuse;

        varying vec2 vUv;

        const float a[5] = float[5](3.4, 4.2, 5.0, 5.2, 1.1);

        const vec4 allColors[8] = vec4[](
                vec4(0.0, 0.0, 0.0, 1.0),
                vec4(0.5, 0.5, 0.5, 1.0),
                vec4(0.68, 0.77, 0.875, 1.0),
                vec4(0.2, 0.19, 0.18, 1.0),
                vec4(0.07, 0.18, 0.07, 1.0),
                vec4(0.34, 0.46, 0.34, 1.0),
                vec4(0.25, 0.19, 0.13, 1.0),
                vec4(0.37, 0.33, 0.29, 1.0)
        );


        vec4 findNearestColor(vec4 col)
        {
            float minDistance = 10.0;
            vec4 nearestCol = vec4(1.0, 1.0, 1.0, 1.0);

            for (int i = 0; i < 8; i++)
            {
                float distance = (
                    abs(col.r - allColors[i].r) +
                    abs(col.g - allColors[i].g) +
                    abs(col.b - allColors[i].b)
                );

                if (distance < minDistance)
                {
                    minDistance = distance;
                    nearestCol = allColors[i];
                }
            }

            return nearestCol;
        }

        void main() {
            
            vec4 sceneCol = texture(tDiffuse, vUv);

            gl_FragColor = findNearestColor(sceneCol);
        }`};export{Lp as Q};
